#
# Autogenerated by Thrift Compiler (0.21.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys

from thrift.transport import TTransport

all_structs = []


class FieldType(object):
    BINARY = 0
    BOOLEAN = 1
    DATE = 2
    DATETIME = 3
    DOUBLE = 4
    FLOAT = 5
    INT96 = 6
    LONG = 7
    INTEGER = 8
    STRING = 9
    STRUCT = 10
    MAP = 11
    ARRAY = 12
    NULL = 13
    TIMESTAMP_TZ = 14

    _VALUES_TO_NAMES = {
        0: "BINARY",
        1: "BOOLEAN",
        2: "DATE",
        3: "DATETIME",
        4: "DOUBLE",
        5: "FLOAT",
        6: "INT96",
        7: "LONG",
        8: "INTEGER",
        9: "STRING",
        10: "STRUCT",
        11: "MAP",
        12: "ARRAY",
        13: "NULL",
        14: "TIMESTAMP_TZ",
    }

    _NAMES_TO_VALUES = {
        "BINARY": 0,
        "BOOLEAN": 1,
        "DATE": 2,
        "DATETIME": 3,
        "DOUBLE": 4,
        "FLOAT": 5,
        "INT96": 6,
        "LONG": 7,
        "INTEGER": 8,
        "STRING": 9,
        "STRUCT": 10,
        "MAP": 11,
        "ARRAY": 12,
        "NULL": 13,
        "TIMESTAMP_TZ": 14,
    }


class E6Partition(object):
    """
    Attributes:
     - partitionInfo
     - numNulls
     - inactiveFiles
     - activePartFiles
     - numRows

    """

    thrift_spec = None

    def __init__(
        self,
        partitionInfo=None,
        numNulls=None,
        inactiveFiles=None,
        activePartFiles=None,
        numRows=None,
    ):
        self.partitionInfo = partitionInfo
        self.numNulls = numNulls
        self.inactiveFiles = inactiveFiles
        self.activePartFiles = activePartFiles
        self.numRows = numRows

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.partitionInfo = E6PartitionInfo()
                    self.partitionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.numNulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.inactiveFiles = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.inactiveFiles.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.activePartFiles = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = PartFile()
                        _elem11.read(iprot)
                        self.activePartFiles.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.numRows = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("E6Partition")
        if self.partitionInfo is not None:
            oprot.writeFieldBegin("partitionInfo", TType.STRUCT, 1)
            self.partitionInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.numNulls is not None:
            oprot.writeFieldBegin("numNulls", TType.I64, 2)
            oprot.writeI64(self.numNulls)
            oprot.writeFieldEnd()
        if self.inactiveFiles is not None:
            oprot.writeFieldBegin("inactiveFiles", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.inactiveFiles))
            for iter12 in self.inactiveFiles:
                oprot.writeString(iter12.encode("utf-8") if sys.version_info[0] == 2 else iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.activePartFiles is not None:
            oprot.writeFieldBegin("activePartFiles", TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.activePartFiles))
            for iter13 in self.activePartFiles:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.numRows is not None:
            oprot.writeFieldBegin("numRows", TType.I64, 5)
            oprot.writeI64(self.numRows)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OptionalString(object):
    """
    Attributes:
     - value

    """

    thrift_spec = None

    def __init__(
        self,
        value=None,
    ):
        self.value = value

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("OptionalString")
        if self.value is not None:
            oprot.writeFieldBegin("value", TType.STRING, 1)
            oprot.writeString(
                self.value.encode("utf-8") if sys.version_info[0] == 2 else self.value
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class E6PartitionInfo(object):
    """
    Attributes:
     - filePathName
     - fieldNames
     - fieldValues
     - fieldTypes
     - containsRecordCount
     - virtualPartitionId
     - virtualPartitionVersionId

    """

    thrift_spec = None

    def __init__(
        self,
        filePathName=None,
        fieldNames=None,
        fieldValues=None,
        fieldTypes=None,
        containsRecordCount=None,
        virtualPartitionId=None,
        virtualPartitionVersionId=None,
    ):
        self.filePathName = filePathName
        self.fieldNames = fieldNames
        self.fieldValues = fieldValues
        self.fieldTypes = fieldTypes
        self.containsRecordCount = containsRecordCount
        self.virtualPartitionId = virtualPartitionId
        self.virtualPartitionVersionId = virtualPartitionVersionId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.filePathName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fieldNames = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.fieldNames.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.fieldValues = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = OptionalString()
                        _elem25.read(iprot)
                        self.fieldValues.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.fieldTypes = []
                    (_etype29, _size26) = iprot.readListBegin()
                    for _i30 in range(_size26):
                        _elem31 = iprot.readI32()
                        self.fieldTypes.append(_elem31)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.containsRecordCount = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.virtualPartitionId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.virtualPartitionVersionId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("E6PartitionInfo")
        if self.filePathName is not None:
            oprot.writeFieldBegin("filePathName", TType.STRING, 1)
            oprot.writeString(
                self.filePathName.encode("utf-8") if sys.version_info[0] == 2 else self.filePathName
            )
            oprot.writeFieldEnd()
        if self.fieldNames is not None:
            oprot.writeFieldBegin("fieldNames", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.fieldNames))
            for iter32 in self.fieldNames:
                oprot.writeString(iter32.encode("utf-8") if sys.version_info[0] == 2 else iter32)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fieldValues is not None:
            oprot.writeFieldBegin("fieldValues", TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.fieldValues))
            for iter33 in self.fieldValues:
                iter33.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fieldTypes is not None:
            oprot.writeFieldBegin("fieldTypes", TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.fieldTypes))
            for iter34 in self.fieldTypes:
                oprot.writeI32(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.containsRecordCount is not None:
            oprot.writeFieldBegin("containsRecordCount", TType.BOOL, 5)
            oprot.writeBool(self.containsRecordCount)
            oprot.writeFieldEnd()
        if self.virtualPartitionId is not None:
            oprot.writeFieldBegin("virtualPartitionId", TType.STRING, 6)
            oprot.writeString(
                self.virtualPartitionId.encode("utf-8")
                if sys.version_info[0] == 2
                else self.virtualPartitionId
            )
            oprot.writeFieldEnd()
        if self.virtualPartitionVersionId is not None:
            oprot.writeFieldBegin("virtualPartitionVersionId", TType.STRING, 7)
            oprot.writeString(
                self.virtualPartitionVersionId.encode("utf-8")
                if sys.version_info[0] == 2
                else self.virtualPartitionVersionId
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartFile(object):
    """
    Attributes:
     - filePath
     - fileSizeInBytes
     - numRecords
     - footer
     - rowIndexOffsets
     - additionalInfo

    """

    thrift_spec = None

    def __init__(
        self,
        filePath=None,
        fileSizeInBytes=None,
        numRecords=None,
        footer=None,
        rowIndexOffsets=None,
        additionalInfo=None,
    ):
        self.filePath = filePath
        self.fileSizeInBytes = fileSizeInBytes
        self.numRecords = numRecords
        self.footer = footer
        self.rowIndexOffsets = rowIndexOffsets
        self.additionalInfo = additionalInfo

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.filePath = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.fileSizeInBytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.numRecords = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.footer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.rowIndexOffsets = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readI64()
                        self.rowIndexOffsets.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.additionalInfo = AdditionalInfo()
                    self.additionalInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("PartFile")
        if self.filePath is not None:
            oprot.writeFieldBegin("filePath", TType.STRING, 1)
            oprot.writeString(
                self.filePath.encode("utf-8") if sys.version_info[0] == 2 else self.filePath
            )
            oprot.writeFieldEnd()
        if self.fileSizeInBytes is not None:
            oprot.writeFieldBegin("fileSizeInBytes", TType.I64, 2)
            oprot.writeI64(self.fileSizeInBytes)
            oprot.writeFieldEnd()
        if self.numRecords is not None:
            oprot.writeFieldBegin("numRecords", TType.I64, 3)
            oprot.writeI64(self.numRecords)
            oprot.writeFieldEnd()
        if self.footer is not None:
            oprot.writeFieldBegin("footer", TType.STRING, 4)
            oprot.writeBinary(self.footer)
            oprot.writeFieldEnd()
        if self.rowIndexOffsets is not None:
            oprot.writeFieldBegin("rowIndexOffsets", TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.rowIndexOffsets))
            for iter41 in self.rowIndexOffsets:
                oprot.writeI64(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.additionalInfo is not None:
            oprot.writeFieldBegin("additionalInfo", TType.STRUCT, 6)
            self.additionalInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AdditionalInfo(object):
    """
    Attributes:
     - deltaPartFileInfo
     - icebergPartFileInfo

    """

    thrift_spec = None

    def __init__(
        self,
        deltaPartFileInfo=None,
        icebergPartFileInfo=None,
    ):
        self.deltaPartFileInfo = deltaPartFileInfo
        self.icebergPartFileInfo = icebergPartFileInfo

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deltaPartFileInfo = DeltaPartFileInfo()
                    self.deltaPartFileInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.icebergPartFileInfo = IcebergPartFileInfo()
                    self.icebergPartFileInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("AdditionalInfo")
        if self.deltaPartFileInfo is not None:
            oprot.writeFieldBegin("deltaPartFileInfo", TType.STRUCT, 1)
            self.deltaPartFileInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.icebergPartFileInfo is not None:
            oprot.writeFieldBegin("icebergPartFileInfo", TType.STRUCT, 2)
            self.icebergPartFileInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeltaPartFileInfo(object):
    """
    Attributes:
     - deletionVector
     - stats
     - mapColumnStats
     - tightBounds

    """

    thrift_spec = None

    def __init__(
        self,
        deletionVector=None,
        stats=None,
        mapColumnStats=None,
        tightBounds=None,
    ):
        self.deletionVector = deletionVector
        self.stats = stats
        self.mapColumnStats = mapColumnStats
        self.tightBounds = tightBounds

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deletionVector = DeletionVector()
                    self.deletionVector.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.stats = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = ColumnStats()
                        _elem47.read(iprot)
                        self.stats.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.mapColumnStats = {}
                    (_ktype49, _vtype50, _size48) = iprot.readMapBegin()
                    for _i52 in range(_size48):
                        _key53 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val54 = ColumnStats()
                        _val54.read(iprot)
                        self.mapColumnStats[_key53] = _val54
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.tightBounds = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("DeltaPartFileInfo")
        if self.deletionVector is not None:
            oprot.writeFieldBegin("deletionVector", TType.STRUCT, 1)
            self.deletionVector.write(oprot)
            oprot.writeFieldEnd()
        if self.stats is not None:
            oprot.writeFieldBegin("stats", TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.stats))
            for iter55 in self.stats:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mapColumnStats is not None:
            oprot.writeFieldBegin("mapColumnStats", TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.mapColumnStats))
            for kiter56, viter57 in self.mapColumnStats.items():
                oprot.writeString(kiter56.encode("utf-8") if sys.version_info[0] == 2 else kiter56)
                viter57.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tightBounds is not None:
            oprot.writeFieldBegin("tightBounds", TType.BOOL, 4)
            oprot.writeBool(self.tightBounds)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IcebergPartFileInfo(object):
    """
    Attributes:
     - deletionVector
     - stats
     - mapColumnStats

    """

    thrift_spec = None

    def __init__(
        self,
        deletionVector=None,
        stats=None,
        mapColumnStats=None,
    ):
        self.deletionVector = deletionVector
        self.stats = stats
        self.mapColumnStats = mapColumnStats

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deletionVector = DeletionVector()
                    self.deletionVector.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.stats = []
                    (_etype61, _size58) = iprot.readListBegin()
                    for _i62 in range(_size58):
                        _elem63 = ColumnStats()
                        _elem63.read(iprot)
                        self.stats.append(_elem63)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.mapColumnStats = {}
                    (_ktype65, _vtype66, _size64) = iprot.readMapBegin()
                    for _i68 in range(_size64):
                        _key69 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val70 = ColumnStats()
                        _val70.read(iprot)
                        self.mapColumnStats[_key69] = _val70
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("IcebergPartFileInfo")
        if self.deletionVector is not None:
            oprot.writeFieldBegin("deletionVector", TType.STRUCT, 1)
            self.deletionVector.write(oprot)
            oprot.writeFieldEnd()
        if self.stats is not None:
            oprot.writeFieldBegin("stats", TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.stats))
            for iter71 in self.stats:
                iter71.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mapColumnStats is not None:
            oprot.writeFieldBegin("mapColumnStats", TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.mapColumnStats))
            for kiter72, viter73 in self.mapColumnStats.items():
                oprot.writeString(kiter72.encode("utf-8") if sys.version_info[0] == 2 else kiter72)
                viter73.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeletionVector(object):
    """
    Attributes:
     - storageType
     - pathOrInlineDv
     - offset
     - sizeInBytes
     - cardinality
     - sizeOfFileInBytes

    """

    thrift_spec = None

    def __init__(
        self,
        storageType=None,
        pathOrInlineDv=None,
        offset=None,
        sizeInBytes=None,
        cardinality=None,
        sizeOfFileInBytes=None,
    ):
        self.storageType = storageType
        self.pathOrInlineDv = pathOrInlineDv
        self.offset = offset
        self.sizeInBytes = sizeInBytes
        self.cardinality = cardinality
        self.sizeOfFileInBytes = sizeOfFileInBytes

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storageType = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathOrInlineDv = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.sizeInBytes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.cardinality = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.sizeOfFileInBytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("DeletionVector")
        if self.storageType is not None:
            oprot.writeFieldBegin("storageType", TType.STRING, 1)
            oprot.writeString(
                self.storageType.encode("utf-8") if sys.version_info[0] == 2 else self.storageType
            )
            oprot.writeFieldEnd()
        if self.pathOrInlineDv is not None:
            oprot.writeFieldBegin("pathOrInlineDv", TType.STRING, 2)
            oprot.writeBinary(self.pathOrInlineDv)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin("offset", TType.I32, 3)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.sizeInBytes is not None:
            oprot.writeFieldBegin("sizeInBytes", TType.I32, 4)
            oprot.writeI32(self.sizeInBytes)
            oprot.writeFieldEnd()
        if self.cardinality is not None:
            oprot.writeFieldBegin("cardinality", TType.I64, 5)
            oprot.writeI64(self.cardinality)
            oprot.writeFieldEnd()
        if self.sizeOfFileInBytes is not None:
            oprot.writeFieldBegin("sizeOfFileInBytes", TType.I64, 6)
            oprot.writeI64(self.sizeOfFileInBytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionPartFiles(object):
    """
    Attributes:
     - partition
     - partFiles
     - columnsWithStats

    """

    thrift_spec = None

    def __init__(
        self,
        partition=None,
        partFiles=None,
        columnsWithStats=None,
    ):
        self.partition = partition
        self.partFiles = partFiles
        self.columnsWithStats = columnsWithStats

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.partition = E6PartitionInfo()
                    self.partition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partFiles = []
                    (_etype77, _size74) = iprot.readListBegin()
                    for _i78 in range(_size74):
                        _elem79 = PartFile()
                        _elem79.read(iprot)
                        self.partFiles.append(_elem79)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columnsWithStats = []
                    (_etype83, _size80) = iprot.readListBegin()
                    for _i84 in range(_size80):
                        _elem85 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.columnsWithStats.append(_elem85)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("PartitionPartFiles")
        if self.partition is not None:
            oprot.writeFieldBegin("partition", TType.STRUCT, 1)
            self.partition.write(oprot)
            oprot.writeFieldEnd()
        if self.partFiles is not None:
            oprot.writeFieldBegin("partFiles", TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.partFiles))
            for iter86 in self.partFiles:
                iter86.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnsWithStats is not None:
            oprot.writeFieldBegin("columnsWithStats", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columnsWithStats))
            for iter87 in self.columnsWithStats:
                oprot.writeString(iter87.encode("utf-8") if sys.version_info[0] == 2 else iter87)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LongStats(object):
    """
    Attributes:
     - min
     - max

    """

    thrift_spec = None

    def __init__(
        self,
        min=None,
        max=None,
    ):
        self.min = min
        self.max = max

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.min = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("LongStats")
        if self.min is not None:
            oprot.writeFieldBegin("min", TType.I64, 1)
            oprot.writeI64(self.min)
            oprot.writeFieldEnd()
        if self.max is not None:
            oprot.writeFieldBegin("max", TType.I64, 2)
            oprot.writeI64(self.max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DoubleStats(object):
    """
    Attributes:
     - min
     - max

    """

    thrift_spec = None

    def __init__(
        self,
        min=None,
        max=None,
    ):
        self.min = min
        self.max = max

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.min = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.max = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("DoubleStats")
        if self.min is not None:
            oprot.writeFieldBegin("min", TType.DOUBLE, 1)
            oprot.writeDouble(self.min)
            oprot.writeFieldEnd()
        if self.max is not None:
            oprot.writeFieldBegin("max", TType.DOUBLE, 2)
            oprot.writeDouble(self.max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StringStats(object):
    """
    Attributes:
     - min
     - max

    """

    thrift_spec = None

    def __init__(
        self,
        min=None,
        max=None,
    ):
        self.min = min
        self.max = max

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.min = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.max = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("StringStats")
        if self.min is not None:
            oprot.writeFieldBegin("min", TType.STRING, 1)
            oprot.writeString(self.min.encode("utf-8") if sys.version_info[0] == 2 else self.min)
            oprot.writeFieldEnd()
        if self.max is not None:
            oprot.writeFieldBegin("max", TType.STRING, 2)
            oprot.writeString(self.max.encode("utf-8") if sys.version_info[0] == 2 else self.max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Stats(object):
    """
    Attributes:
     - longStats
     - doubleStats
     - stringStats

    """

    thrift_spec = None

    def __init__(
        self,
        longStats=None,
        doubleStats=None,
        stringStats=None,
    ):
        self.longStats = longStats
        self.doubleStats = doubleStats
        self.stringStats = stringStats

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.longStats = LongStats()
                    self.longStats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.doubleStats = DoubleStats()
                    self.doubleStats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.stringStats = StringStats()
                    self.stringStats.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("Stats")
        if self.longStats is not None:
            oprot.writeFieldBegin("longStats", TType.STRUCT, 1)
            self.longStats.write(oprot)
            oprot.writeFieldEnd()
        if self.doubleStats is not None:
            oprot.writeFieldBegin("doubleStats", TType.STRUCT, 2)
            self.doubleStats.write(oprot)
            oprot.writeFieldEnd()
        if self.stringStats is not None:
            oprot.writeFieldBegin("stringStats", TType.STRUCT, 3)
            self.stringStats.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnStats(object):
    """
    Attributes:
     - stats
     - nullCount

    """

    thrift_spec = None

    def __init__(
        self,
        stats=None,
        nullCount=None,
    ):
        self.stats = stats
        self.nullCount = nullCount

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stats = Stats()
                    self.stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.nullCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("ColumnStats")
        if self.stats is not None:
            oprot.writeFieldBegin("stats", TType.STRUCT, 1)
            self.stats.write(oprot)
            oprot.writeFieldEnd()
        if self.nullCount is not None:
            oprot.writeFieldBegin("nullCount", TType.I64, 2)
            oprot.writeI64(self.nullCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableVersionInfo(object):
    """
    Attributes:
     - timestamp
     - logVersion

    """

    thrift_spec = None

    def __init__(
        self,
        timestamp=None,
        logVersion=None,
    ):
        self.timestamp = timestamp
        self.logVersion = logVersion

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.logVersion = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("TableVersionInfo")
        if self.timestamp is not None:
            oprot.writeFieldBegin("timestamp", TType.I64, 1)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.logVersion is not None:
            oprot.writeFieldBegin("logVersion", TType.I64, 2)
            oprot.writeI64(self.logVersion)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(E6Partition)
E6Partition.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "partitionInfo",
        [E6PartitionInfo, None],
        None,
    ),  # 1
    (
        2,
        TType.I64,
        "numNulls",
        None,
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "inactiveFiles",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "activePartFiles",
        (TType.STRUCT, [PartFile, None], False),
        None,
    ),  # 4
    (
        5,
        TType.I64,
        "numRows",
        None,
        None,
    ),  # 5
)
all_structs.append(OptionalString)
OptionalString.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "value",
        "UTF8",
        None,
    ),  # 1
)
all_structs.append(E6PartitionInfo)
E6PartitionInfo.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "filePathName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "fieldNames",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "fieldValues",
        (TType.STRUCT, [OptionalString, None], False),
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "fieldTypes",
        (TType.I32, None, False),
        None,
    ),  # 4
    (
        5,
        TType.BOOL,
        "containsRecordCount",
        None,
        None,
    ),  # 5
    (
        6,
        TType.STRING,
        "virtualPartitionId",
        "UTF8",
        None,
    ),  # 6
    (
        7,
        TType.STRING,
        "virtualPartitionVersionId",
        "UTF8",
        None,
    ),  # 7
)
all_structs.append(PartFile)
PartFile.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "filePath",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.I64,
        "fileSizeInBytes",
        None,
        None,
    ),  # 2
    (
        3,
        TType.I64,
        "numRecords",
        None,
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "footer",
        "BINARY",
        None,
    ),  # 4
    (
        5,
        TType.LIST,
        "rowIndexOffsets",
        (TType.I64, None, False),
        None,
    ),  # 5
    (
        6,
        TType.STRUCT,
        "additionalInfo",
        [AdditionalInfo, None],
        None,
    ),  # 6
)
all_structs.append(AdditionalInfo)
AdditionalInfo.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "deltaPartFileInfo",
        [DeltaPartFileInfo, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "icebergPartFileInfo",
        [IcebergPartFileInfo, None],
        None,
    ),  # 2
)
all_structs.append(DeltaPartFileInfo)
DeltaPartFileInfo.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "deletionVector",
        [DeletionVector, None],
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "stats",
        (TType.STRUCT, [ColumnStats, None], False),
        None,
    ),  # 2
    (
        3,
        TType.MAP,
        "mapColumnStats",
        (TType.STRING, "UTF8", TType.STRUCT, [ColumnStats, None], False),
        None,
    ),  # 3
    (
        4,
        TType.BOOL,
        "tightBounds",
        None,
        None,
    ),  # 4
)
all_structs.append(IcebergPartFileInfo)
IcebergPartFileInfo.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "deletionVector",
        [DeletionVector, None],
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "stats",
        (TType.STRUCT, [ColumnStats, None], False),
        None,
    ),  # 2
    (
        3,
        TType.MAP,
        "mapColumnStats",
        (TType.STRING, "UTF8", TType.STRUCT, [ColumnStats, None], False),
        None,
    ),  # 3
)
all_structs.append(DeletionVector)
DeletionVector.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "storageType",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "pathOrInlineDv",
        "BINARY",
        None,
    ),  # 2
    (
        3,
        TType.I32,
        "offset",
        None,
        None,
    ),  # 3
    (
        4,
        TType.I32,
        "sizeInBytes",
        None,
        None,
    ),  # 4
    (
        5,
        TType.I64,
        "cardinality",
        None,
        None,
    ),  # 5
    (
        6,
        TType.I64,
        "sizeOfFileInBytes",
        None,
        None,
    ),  # 6
)
all_structs.append(PartitionPartFiles)
PartitionPartFiles.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "partition",
        [E6PartitionInfo, None],
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "partFiles",
        (TType.STRUCT, [PartFile, None], False),
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "columnsWithStats",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
)
all_structs.append(LongStats)
LongStats.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I64,
        "min",
        None,
        None,
    ),  # 1
    (
        2,
        TType.I64,
        "max",
        None,
        None,
    ),  # 2
)
all_structs.append(DoubleStats)
DoubleStats.thrift_spec = (
    None,  # 0
    (
        1,
        TType.DOUBLE,
        "min",
        None,
        None,
    ),  # 1
    (
        2,
        TType.DOUBLE,
        "max",
        None,
        None,
    ),  # 2
)
all_structs.append(StringStats)
StringStats.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "min",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "max",
        "UTF8",
        None,
    ),  # 2
)
all_structs.append(Stats)
Stats.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "longStats",
        [LongStats, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "doubleStats",
        [DoubleStats, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "stringStats",
        [StringStats, None],
        None,
    ),  # 3
)
all_structs.append(ColumnStats)
ColumnStats.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "stats",
        [Stats, None],
        None,
    ),  # 1
    (
        2,
        TType.I64,
        "nullCount",
        None,
        None,
    ),  # 2
)
all_structs.append(TableVersionInfo)
TableVersionInfo.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I64,
        "timestamp",
        None,
        None,
    ),  # 1
    (
        2,
        TType.I64,
        "logVersion",
        None,
        None,
    ),  # 2
)
fix_spec(all_structs)
del all_structs
