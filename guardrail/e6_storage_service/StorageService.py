#
# Autogenerated by Thrift Compiler (0.21.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport

all_structs = []


class Iface(object):
    def getConnectionMetadata(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        pass

    def getCatalogNames(self):
        pass

    def getDBNames(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        pass

    def getTableNames(self, catalogName, dbName):
        """
        Parameters:
         - catalogName
         - dbName

        """
        pass

    def getColumns(self, catalogName, dbName, tableName):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName

        """
        pass

    def getColumnsForTables(self, catalogName, dbName, tableName):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName

        """
        pass

    def getColumnsForAllTablesInDb(self, catalogName, dbName):
        """
        Parameters:
         - catalogName
         - dbName

        """
        pass

    def getColumnsForAllTablesInCatalog(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        pass

    def getCatalogNamesV2(self, userContext):
        """
        Parameters:
         - userContext

        """
        pass

    def getDBNamesV2(self, userContext, catalogName):
        """
        Parameters:
         - userContext
         - catalogName

        """
        pass

    def getTableNamesV2(self, userContext, catalogName, dbName):
        """
        Parameters:
         - userContext
         - catalogName
         - dbName

        """
        pass

    def getColumnsV2(self, userContext, catalogName, dbName, tableName):
        """
        Parameters:
         - userContext
         - catalogName
         - dbName
         - tableName

        """
        pass

    def getColumnsForTablesV2(self, userContext, catalogName, dbName, tableName):
        """
        Parameters:
         - userContext
         - catalogName
         - dbName
         - tableName

        """
        pass

    def getColumnsForAllTablesInDbV2(self, userContext, catalogName, dbName):
        """
        Parameters:
         - userContext
         - catalogName
         - dbName

        """
        pass

    def getColumnsForAllTablesInCatalogV2(self, userContext, catalogName):
        """
        Parameters:
         - userContext
         - catalogName

        """
        pass

    def getTableMetadata(self, catalogName, dbName, tableName, requestId):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId

        """
        pass

    def getDBObjects(self, catalogName, dbName):
        """
        Parameters:
         - catalogName
         - dbName

        """
        pass

    def getDBObjectsV2(self, userContext, catalogName, dbName):
        """
        Parameters:
         - userContext
         - catalogName
         - dbName

        """
        pass

    def getTableStatistics(self, catalogName, dbName, tableName, requestId):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId

        """
        pass

    def getTableStatisticsV2(self, catalogName, dbName, tableName, requestId):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId

        """
        pass

    def getTablePartitionsAtVersion(
        self, catalogName, dbName, tableName, requestId, timeTravelInfo
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId
         - timeTravelInfo

        """
        pass

    def getTablePartitionFileAndMetadataAtVersion(
        self,
        catalogName,
        dbName,
        tableName,
        partitions,
        requestId,
        timeTravelInfo,
        shouldGetFileMetadata,
        columnsWithStats,
        getStatsForAllColumns,
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - partitions
         - requestId
         - timeTravelInfo
         - shouldGetFileMetadata
         - columnsWithStats
         - getStatsForAllColumns

        """
        pass

    def getTablePartitions(
        self, catalogName, dbName, tableName, requestId, forceRefresh, lastUpdateTimeFromCache
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId
         - forceRefresh
         - lastUpdateTimeFromCache

        """
        pass

    def getTablePartitionFileAndMetadata(
        self,
        catalogName,
        dbName,
        tableName,
        partitions,
        requestId,
        forcerefresh,
        shouldGetFileMetadata,
        columnsWithStats,
        getStatsForAllColumns,
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - partitions
         - requestId
         - forcerefresh
         - shouldGetFileMetadata
         - columnsWithStats
         - getStatsForAllColumns

        """
        pass

    def putFileMetadata(self, partFiles, requestId):
        """
        Parameters:
         - partFiles
         - requestId

        """
        pass

    def bulkAddCatalogs(self, catalogsJson):
        """
        Parameters:
         - catalogsJson

        """
        pass

    def refreshCatalog(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        pass

    def getAddOrRefreshCatalogResponse(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        pass

    def forceBulkAddCatalogs(self):
        pass

    def refreshDBs(self, catalogName, dbName):
        """
        Parameters:
         - catalogName
         - dbName

        """
        pass

    def getRefreshDBsResponse(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        pass

    def dropCatalog(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        pass

    def dBNamesCallback(self, dbNames, requestContext):
        """
        Parameters:
         - dbNames
         - requestContext

        """
        pass

    def tableNamesCallback(self, tableNames, requestContext):
        """
        Parameters:
         - tableNames
         - requestContext

        """
        pass

    def tablesCallback(self, listTablesCallback, requestContext):
        """
        Parameters:
         - listTablesCallback
         - requestContext

        """
        pass

    def tableStatisticsCallback(self, tableStats, requestContext):
        """
        Parameters:
         - tableStats
         - requestContext

        """
        pass

    def tablePartitionsCallback(self, partitions, requestContext):
        """
        Parameters:
         - partitions
         - requestContext

        """
        pass

    def deltaTablePartitionsCallback(self, deltaTableChangeResponse, requestContext):
        """
        Parameters:
         - deltaTableChangeResponse
         - requestContext

        """
        pass

    def tablePartitionFilesCallback(self, mapPartitionNameAndFileMetadatas, requestContext):
        """
        Parameters:
         - mapPartitionNameAndFileMetadatas
         - requestContext

        """
        pass

    def tableFileMetadataCallback(self, listFileMetadata, requestContext):
        """
        Parameters:
         - listFileMetadata
         - requestContext

        """
        pass

    def getAdditionalDataCallback(self, mapPartitiontoDeletionVectors, requestContext):
        """
        Parameters:
         - mapPartitiontoDeletionVectors
         - requestContext

        """
        pass

    def upsertDBNames(self, catalogName, dbNames):
        """
        Parameters:
         - catalogName
         - dbNames

        """
        pass

    def upsertTableNames(self, catalogName, dbName, tableNames):
        """
        Parameters:
         - catalogName
         - dbName
         - tableNames

        """
        pass

    def upsertTables(self, catalogName, dbName, tables):
        """
        Parameters:
         - catalogName
         - dbName
         - tables

        """
        pass

    def upsertTableStatistics(self, catalogName, dbName, tableName, tableStats):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - tableStats

        """
        pass

    def upsertTablePartitions(self, catalogName, dbName, tableName, partitions):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - partitions

        """
        pass

    def upsertTablePartitionFiles(
        self, catalogName, dbName, tableName, mapPartitionNameAndFileMetadata
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - mapPartitionNameAndFileMetadata

        """
        pass

    def upsertTableFileMetadata(self, catalogName, dbName, tableName, fileMetadata):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - fileMetadata

        """
        pass

    def getCatalogDump(self, catalogDumpRequest):
        """
        Parameters:
         - catalogDumpRequest

        """
        pass

    def analyzeTable(self, catalogName, dbName, tableName, columnNames, requestId):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - columnNames
         - requestId

        """
        pass

    def getAnalyzedTableInfo(self, catalogName, dbName, tableName, requestId):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId

        """
        pass

    def getHistoricalStats(self):
        pass

    def updateHBOCacheInStorage(self, stats):
        """
        Parameters:
         - stats

        """
        pass

    def createView(self, catalogName, databaseName, tableName, requestId, table):
        """
        Parameters:
         - catalogName
         - databaseName
         - tableName
         - requestId
         - table

        """
        pass

    def updateView(self, catalogName, databaseName, tableName, table, requestId):
        """
        Parameters:
         - catalogName
         - databaseName
         - tableName
         - table
         - requestId

        """
        pass

    def alterView(self, catalogName, databaseName, tableName, requestId, table):
        """
        Parameters:
         - catalogName
         - databaseName
         - tableName
         - requestId
         - table

        """
        pass

    def dropView(self, catalogName, databaseName, tableName, requestId):
        """
        Parameters:
         - catalogName
         - databaseName
         - tableName
         - requestId

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getConnectionMetadata(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        self.send_getConnectionMetadata(catalogName)
        return self.recv_getConnectionMetadata()

    def send_getConnectionMetadata(self, catalogName):
        self._oprot.writeMessageBegin("getConnectionMetadata", TMessageType.CALL, self._seqid)
        args = getConnectionMetadata_args()
        args.catalogName = catalogName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getConnectionMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getConnectionMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getConnectionMetadata failed: unknown result"
        )

    def getCatalogNames(self):
        self.send_getCatalogNames()
        return self.recv_getCatalogNames()

    def send_getCatalogNames(self):
        self._oprot.writeMessageBegin("getCatalogNames", TMessageType.CALL, self._seqid)
        args = getCatalogNames_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCatalogNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCatalogNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getCatalogNames failed: unknown result"
        )

    def getDBNames(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        self.send_getDBNames(catalogName)
        return self.recv_getDBNames()

    def send_getDBNames(self, catalogName):
        self._oprot.writeMessageBegin("getDBNames", TMessageType.CALL, self._seqid)
        args = getDBNames_args()
        args.catalogName = catalogName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDBNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDBNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getDBNames failed: unknown result"
        )

    def getTableNames(self, catalogName, dbName):
        """
        Parameters:
         - catalogName
         - dbName

        """
        self.send_getTableNames(catalogName, dbName)
        return self.recv_getTableNames()

    def send_getTableNames(self, catalogName, dbName):
        self._oprot.writeMessageBegin("getTableNames", TMessageType.CALL, self._seqid)
        args = getTableNames_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getTableNames failed: unknown result"
        )

    def getColumns(self, catalogName, dbName, tableName):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName

        """
        self.send_getColumns(catalogName, dbName, tableName)
        return self.recv_getColumns()

    def send_getColumns(self, catalogName, dbName, tableName):
        self._oprot.writeMessageBegin("getColumns", TMessageType.CALL, self._seqid)
        args = getColumns_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getColumns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getColumns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getColumns failed: unknown result"
        )

    def getColumnsForTables(self, catalogName, dbName, tableName):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName

        """
        self.send_getColumnsForTables(catalogName, dbName, tableName)
        return self.recv_getColumnsForTables()

    def send_getColumnsForTables(self, catalogName, dbName, tableName):
        self._oprot.writeMessageBegin("getColumnsForTables", TMessageType.CALL, self._seqid)
        args = getColumnsForTables_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getColumnsForTables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getColumnsForTables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getColumnsForTables failed: unknown result"
        )

    def getColumnsForAllTablesInDb(self, catalogName, dbName):
        """
        Parameters:
         - catalogName
         - dbName

        """
        self.send_getColumnsForAllTablesInDb(catalogName, dbName)
        return self.recv_getColumnsForAllTablesInDb()

    def send_getColumnsForAllTablesInDb(self, catalogName, dbName):
        self._oprot.writeMessageBegin("getColumnsForAllTablesInDb", TMessageType.CALL, self._seqid)
        args = getColumnsForAllTablesInDb_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getColumnsForAllTablesInDb(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getColumnsForAllTablesInDb_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getColumnsForAllTablesInDb failed: unknown result",
        )

    def getColumnsForAllTablesInCatalog(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        self.send_getColumnsForAllTablesInCatalog(catalogName)
        return self.recv_getColumnsForAllTablesInCatalog()

    def send_getColumnsForAllTablesInCatalog(self, catalogName):
        self._oprot.writeMessageBegin(
            "getColumnsForAllTablesInCatalog", TMessageType.CALL, self._seqid
        )
        args = getColumnsForAllTablesInCatalog_args()
        args.catalogName = catalogName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getColumnsForAllTablesInCatalog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getColumnsForAllTablesInCatalog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getColumnsForAllTablesInCatalog failed: unknown result",
        )

    def getCatalogNamesV2(self, userContext):
        """
        Parameters:
         - userContext

        """
        self.send_getCatalogNamesV2(userContext)
        return self.recv_getCatalogNamesV2()

    def send_getCatalogNamesV2(self, userContext):
        self._oprot.writeMessageBegin("getCatalogNamesV2", TMessageType.CALL, self._seqid)
        args = getCatalogNamesV2_args()
        args.userContext = userContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCatalogNamesV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCatalogNamesV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getCatalogNamesV2 failed: unknown result"
        )

    def getDBNamesV2(self, userContext, catalogName):
        """
        Parameters:
         - userContext
         - catalogName

        """
        self.send_getDBNamesV2(userContext, catalogName)
        return self.recv_getDBNamesV2()

    def send_getDBNamesV2(self, userContext, catalogName):
        self._oprot.writeMessageBegin("getDBNamesV2", TMessageType.CALL, self._seqid)
        args = getDBNamesV2_args()
        args.userContext = userContext
        args.catalogName = catalogName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDBNamesV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDBNamesV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getDBNamesV2 failed: unknown result"
        )

    def getTableNamesV2(self, userContext, catalogName, dbName):
        """
        Parameters:
         - userContext
         - catalogName
         - dbName

        """
        self.send_getTableNamesV2(userContext, catalogName, dbName)
        return self.recv_getTableNamesV2()

    def send_getTableNamesV2(self, userContext, catalogName, dbName):
        self._oprot.writeMessageBegin("getTableNamesV2", TMessageType.CALL, self._seqid)
        args = getTableNamesV2_args()
        args.userContext = userContext
        args.catalogName = catalogName
        args.dbName = dbName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableNamesV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableNamesV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getTableNamesV2 failed: unknown result"
        )

    def getColumnsV2(self, userContext, catalogName, dbName, tableName):
        """
        Parameters:
         - userContext
         - catalogName
         - dbName
         - tableName

        """
        self.send_getColumnsV2(userContext, catalogName, dbName, tableName)
        return self.recv_getColumnsV2()

    def send_getColumnsV2(self, userContext, catalogName, dbName, tableName):
        self._oprot.writeMessageBegin("getColumnsV2", TMessageType.CALL, self._seqid)
        args = getColumnsV2_args()
        args.userContext = userContext
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getColumnsV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getColumnsV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getColumnsV2 failed: unknown result"
        )

    def getColumnsForTablesV2(self, userContext, catalogName, dbName, tableName):
        """
        Parameters:
         - userContext
         - catalogName
         - dbName
         - tableName

        """
        self.send_getColumnsForTablesV2(userContext, catalogName, dbName, tableName)
        return self.recv_getColumnsForTablesV2()

    def send_getColumnsForTablesV2(self, userContext, catalogName, dbName, tableName):
        self._oprot.writeMessageBegin("getColumnsForTablesV2", TMessageType.CALL, self._seqid)
        args = getColumnsForTablesV2_args()
        args.userContext = userContext
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getColumnsForTablesV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getColumnsForTablesV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getColumnsForTablesV2 failed: unknown result"
        )

    def getColumnsForAllTablesInDbV2(self, userContext, catalogName, dbName):
        """
        Parameters:
         - userContext
         - catalogName
         - dbName

        """
        self.send_getColumnsForAllTablesInDbV2(userContext, catalogName, dbName)
        return self.recv_getColumnsForAllTablesInDbV2()

    def send_getColumnsForAllTablesInDbV2(self, userContext, catalogName, dbName):
        self._oprot.writeMessageBegin(
            "getColumnsForAllTablesInDbV2", TMessageType.CALL, self._seqid
        )
        args = getColumnsForAllTablesInDbV2_args()
        args.userContext = userContext
        args.catalogName = catalogName
        args.dbName = dbName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getColumnsForAllTablesInDbV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getColumnsForAllTablesInDbV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getColumnsForAllTablesInDbV2 failed: unknown result",
        )

    def getColumnsForAllTablesInCatalogV2(self, userContext, catalogName):
        """
        Parameters:
         - userContext
         - catalogName

        """
        self.send_getColumnsForAllTablesInCatalogV2(userContext, catalogName)
        return self.recv_getColumnsForAllTablesInCatalogV2()

    def send_getColumnsForAllTablesInCatalogV2(self, userContext, catalogName):
        self._oprot.writeMessageBegin(
            "getColumnsForAllTablesInCatalogV2", TMessageType.CALL, self._seqid
        )
        args = getColumnsForAllTablesInCatalogV2_args()
        args.userContext = userContext
        args.catalogName = catalogName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getColumnsForAllTablesInCatalogV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getColumnsForAllTablesInCatalogV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getColumnsForAllTablesInCatalogV2 failed: unknown result",
        )

    def getTableMetadata(self, catalogName, dbName, tableName, requestId):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId

        """
        self.send_getTableMetadata(catalogName, dbName, tableName, requestId)
        return self.recv_getTableMetadata()

    def send_getTableMetadata(self, catalogName, dbName, tableName, requestId):
        self._oprot.writeMessageBegin("getTableMetadata", TMessageType.CALL, self._seqid)
        args = getTableMetadata_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.requestId = requestId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getTableMetadata failed: unknown result"
        )

    def getDBObjects(self, catalogName, dbName):
        """
        Parameters:
         - catalogName
         - dbName

        """
        self.send_getDBObjects(catalogName, dbName)
        return self.recv_getDBObjects()

    def send_getDBObjects(self, catalogName, dbName):
        self._oprot.writeMessageBegin("getDBObjects", TMessageType.CALL, self._seqid)
        args = getDBObjects_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDBObjects(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDBObjects_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getDBObjects failed: unknown result"
        )

    def getDBObjectsV2(self, userContext, catalogName, dbName):
        """
        Parameters:
         - userContext
         - catalogName
         - dbName

        """
        self.send_getDBObjectsV2(userContext, catalogName, dbName)
        return self.recv_getDBObjectsV2()

    def send_getDBObjectsV2(self, userContext, catalogName, dbName):
        self._oprot.writeMessageBegin("getDBObjectsV2", TMessageType.CALL, self._seqid)
        args = getDBObjectsV2_args()
        args.userContext = userContext
        args.catalogName = catalogName
        args.dbName = dbName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDBObjectsV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDBObjectsV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getDBObjectsV2 failed: unknown result"
        )

    def getTableStatistics(self, catalogName, dbName, tableName, requestId):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId

        """
        self.send_getTableStatistics(catalogName, dbName, tableName, requestId)
        return self.recv_getTableStatistics()

    def send_getTableStatistics(self, catalogName, dbName, tableName, requestId):
        self._oprot.writeMessageBegin("getTableStatistics", TMessageType.CALL, self._seqid)
        args = getTableStatistics_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.requestId = requestId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableStatistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableStatistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getTableStatistics failed: unknown result"
        )

    def getTableStatisticsV2(self, catalogName, dbName, tableName, requestId):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId

        """
        self.send_getTableStatisticsV2(catalogName, dbName, tableName, requestId)
        return self.recv_getTableStatisticsV2()

    def send_getTableStatisticsV2(self, catalogName, dbName, tableName, requestId):
        self._oprot.writeMessageBegin("getTableStatisticsV2", TMessageType.CALL, self._seqid)
        args = getTableStatisticsV2_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.requestId = requestId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableStatisticsV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableStatisticsV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getTableStatisticsV2 failed: unknown result"
        )

    def getTablePartitionsAtVersion(
        self, catalogName, dbName, tableName, requestId, timeTravelInfo
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId
         - timeTravelInfo

        """
        self.send_getTablePartitionsAtVersion(
            catalogName, dbName, tableName, requestId, timeTravelInfo
        )
        return self.recv_getTablePartitionsAtVersion()

    def send_getTablePartitionsAtVersion(
        self, catalogName, dbName, tableName, requestId, timeTravelInfo
    ):
        self._oprot.writeMessageBegin("getTablePartitionsAtVersion", TMessageType.CALL, self._seqid)
        args = getTablePartitionsAtVersion_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.requestId = requestId
        args.timeTravelInfo = timeTravelInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTablePartitionsAtVersion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTablePartitionsAtVersion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getTablePartitionsAtVersion failed: unknown result",
        )

    def getTablePartitionFileAndMetadataAtVersion(
        self,
        catalogName,
        dbName,
        tableName,
        partitions,
        requestId,
        timeTravelInfo,
        shouldGetFileMetadata,
        columnsWithStats,
        getStatsForAllColumns,
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - partitions
         - requestId
         - timeTravelInfo
         - shouldGetFileMetadata
         - columnsWithStats
         - getStatsForAllColumns

        """
        self.send_getTablePartitionFileAndMetadataAtVersion(
            catalogName,
            dbName,
            tableName,
            partitions,
            requestId,
            timeTravelInfo,
            shouldGetFileMetadata,
            columnsWithStats,
            getStatsForAllColumns,
        )
        return self.recv_getTablePartitionFileAndMetadataAtVersion()

    def send_getTablePartitionFileAndMetadataAtVersion(
        self,
        catalogName,
        dbName,
        tableName,
        partitions,
        requestId,
        timeTravelInfo,
        shouldGetFileMetadata,
        columnsWithStats,
        getStatsForAllColumns,
    ):
        self._oprot.writeMessageBegin(
            "getTablePartitionFileAndMetadataAtVersion", TMessageType.CALL, self._seqid
        )
        args = getTablePartitionFileAndMetadataAtVersion_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.partitions = partitions
        args.requestId = requestId
        args.timeTravelInfo = timeTravelInfo
        args.shouldGetFileMetadata = shouldGetFileMetadata
        args.columnsWithStats = columnsWithStats
        args.getStatsForAllColumns = getStatsForAllColumns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTablePartitionFileAndMetadataAtVersion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTablePartitionFileAndMetadataAtVersion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getTablePartitionFileAndMetadataAtVersion failed: unknown result",
        )

    def getTablePartitions(
        self, catalogName, dbName, tableName, requestId, forceRefresh, lastUpdateTimeFromCache
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId
         - forceRefresh
         - lastUpdateTimeFromCache

        """
        self.send_getTablePartitions(
            catalogName, dbName, tableName, requestId, forceRefresh, lastUpdateTimeFromCache
        )
        return self.recv_getTablePartitions()

    def send_getTablePartitions(
        self, catalogName, dbName, tableName, requestId, forceRefresh, lastUpdateTimeFromCache
    ):
        self._oprot.writeMessageBegin("getTablePartitions", TMessageType.CALL, self._seqid)
        args = getTablePartitions_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.requestId = requestId
        args.forceRefresh = forceRefresh
        args.lastUpdateTimeFromCache = lastUpdateTimeFromCache
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTablePartitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTablePartitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getTablePartitions failed: unknown result"
        )

    def getTablePartitionFileAndMetadata(
        self,
        catalogName,
        dbName,
        tableName,
        partitions,
        requestId,
        forcerefresh,
        shouldGetFileMetadata,
        columnsWithStats,
        getStatsForAllColumns,
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - partitions
         - requestId
         - forcerefresh
         - shouldGetFileMetadata
         - columnsWithStats
         - getStatsForAllColumns

        """
        self.send_getTablePartitionFileAndMetadata(
            catalogName,
            dbName,
            tableName,
            partitions,
            requestId,
            forcerefresh,
            shouldGetFileMetadata,
            columnsWithStats,
            getStatsForAllColumns,
        )
        return self.recv_getTablePartitionFileAndMetadata()

    def send_getTablePartitionFileAndMetadata(
        self,
        catalogName,
        dbName,
        tableName,
        partitions,
        requestId,
        forcerefresh,
        shouldGetFileMetadata,
        columnsWithStats,
        getStatsForAllColumns,
    ):
        self._oprot.writeMessageBegin(
            "getTablePartitionFileAndMetadata", TMessageType.CALL, self._seqid
        )
        args = getTablePartitionFileAndMetadata_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.partitions = partitions
        args.requestId = requestId
        args.forcerefresh = forcerefresh
        args.shouldGetFileMetadata = shouldGetFileMetadata
        args.columnsWithStats = columnsWithStats
        args.getStatsForAllColumns = getStatsForAllColumns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTablePartitionFileAndMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTablePartitionFileAndMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getTablePartitionFileAndMetadata failed: unknown result",
        )

    def putFileMetadata(self, partFiles, requestId):
        """
        Parameters:
         - partFiles
         - requestId

        """
        self.send_putFileMetadata(partFiles, requestId)

    def send_putFileMetadata(self, partFiles, requestId):
        self._oprot.writeMessageBegin("putFileMetadata", TMessageType.ONEWAY, self._seqid)
        args = putFileMetadata_args()
        args.partFiles = partFiles
        args.requestId = requestId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def bulkAddCatalogs(self, catalogsJson):
        """
        Parameters:
         - catalogsJson

        """
        self.send_bulkAddCatalogs(catalogsJson)
        return self.recv_bulkAddCatalogs()

    def send_bulkAddCatalogs(self, catalogsJson):
        self._oprot.writeMessageBegin("bulkAddCatalogs", TMessageType.CALL, self._seqid)
        args = bulkAddCatalogs_args()
        args.catalogsJson = catalogsJson
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_bulkAddCatalogs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = bulkAddCatalogs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "bulkAddCatalogs failed: unknown result"
        )

    def refreshCatalog(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        self.send_refreshCatalog(catalogName)
        return self.recv_refreshCatalog()

    def send_refreshCatalog(self, catalogName):
        self._oprot.writeMessageBegin("refreshCatalog", TMessageType.CALL, self._seqid)
        args = refreshCatalog_args()
        args.catalogName = catalogName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_refreshCatalog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = refreshCatalog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "refreshCatalog failed: unknown result"
        )

    def getAddOrRefreshCatalogResponse(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        self.send_getAddOrRefreshCatalogResponse(catalogName)
        return self.recv_getAddOrRefreshCatalogResponse()

    def send_getAddOrRefreshCatalogResponse(self, catalogName):
        self._oprot.writeMessageBegin(
            "getAddOrRefreshCatalogResponse", TMessageType.CALL, self._seqid
        )
        args = getAddOrRefreshCatalogResponse_args()
        args.catalogName = catalogName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAddOrRefreshCatalogResponse(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAddOrRefreshCatalogResponse_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getAddOrRefreshCatalogResponse failed: unknown result",
        )

    def forceBulkAddCatalogs(self):
        self.send_forceBulkAddCatalogs()
        return self.recv_forceBulkAddCatalogs()

    def send_forceBulkAddCatalogs(self):
        self._oprot.writeMessageBegin("forceBulkAddCatalogs", TMessageType.CALL, self._seqid)
        args = forceBulkAddCatalogs_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forceBulkAddCatalogs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forceBulkAddCatalogs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "forceBulkAddCatalogs failed: unknown result"
        )

    def refreshDBs(self, catalogName, dbName):
        """
        Parameters:
         - catalogName
         - dbName

        """
        self.send_refreshDBs(catalogName, dbName)
        return self.recv_refreshDBs()

    def send_refreshDBs(self, catalogName, dbName):
        self._oprot.writeMessageBegin("refreshDBs", TMessageType.CALL, self._seqid)
        args = refreshDBs_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_refreshDBs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = refreshDBs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "refreshDBs failed: unknown result"
        )

    def getRefreshDBsResponse(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        self.send_getRefreshDBsResponse(catalogName)
        return self.recv_getRefreshDBsResponse()

    def send_getRefreshDBsResponse(self, catalogName):
        self._oprot.writeMessageBegin("getRefreshDBsResponse", TMessageType.CALL, self._seqid)
        args = getRefreshDBsResponse_args()
        args.catalogName = catalogName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRefreshDBsResponse(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRefreshDBsResponse_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getRefreshDBsResponse failed: unknown result"
        )

    def dropCatalog(self, catalogName):
        """
        Parameters:
         - catalogName

        """
        self.send_dropCatalog(catalogName)
        self.recv_dropCatalog()

    def send_dropCatalog(self, catalogName):
        self._oprot.writeMessageBegin("dropCatalog", TMessageType.CALL, self._seqid)
        args = dropCatalog_args()
        args.catalogName = catalogName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dropCatalog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dropCatalog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def dBNamesCallback(self, dbNames, requestContext):
        """
        Parameters:
         - dbNames
         - requestContext

        """
        self.send_dBNamesCallback(dbNames, requestContext)
        self.recv_dBNamesCallback()

    def send_dBNamesCallback(self, dbNames, requestContext):
        self._oprot.writeMessageBegin("dBNamesCallback", TMessageType.CALL, self._seqid)
        args = dBNamesCallback_args()
        args.dbNames = dbNames
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dBNamesCallback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dBNamesCallback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def tableNamesCallback(self, tableNames, requestContext):
        """
        Parameters:
         - tableNames
         - requestContext

        """
        self.send_tableNamesCallback(tableNames, requestContext)
        self.recv_tableNamesCallback()

    def send_tableNamesCallback(self, tableNames, requestContext):
        self._oprot.writeMessageBegin("tableNamesCallback", TMessageType.CALL, self._seqid)
        args = tableNamesCallback_args()
        args.tableNames = tableNames
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tableNamesCallback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tableNamesCallback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def tablesCallback(self, listTablesCallback, requestContext):
        """
        Parameters:
         - listTablesCallback
         - requestContext

        """
        self.send_tablesCallback(listTablesCallback, requestContext)
        self.recv_tablesCallback()

    def send_tablesCallback(self, listTablesCallback, requestContext):
        self._oprot.writeMessageBegin("tablesCallback", TMessageType.CALL, self._seqid)
        args = tablesCallback_args()
        args.listTablesCallback = listTablesCallback
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tablesCallback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tablesCallback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def tableStatisticsCallback(self, tableStats, requestContext):
        """
        Parameters:
         - tableStats
         - requestContext

        """
        self.send_tableStatisticsCallback(tableStats, requestContext)
        self.recv_tableStatisticsCallback()

    def send_tableStatisticsCallback(self, tableStats, requestContext):
        self._oprot.writeMessageBegin("tableStatisticsCallback", TMessageType.CALL, self._seqid)
        args = tableStatisticsCallback_args()
        args.tableStats = tableStats
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tableStatisticsCallback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tableStatisticsCallback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def tablePartitionsCallback(self, partitions, requestContext):
        """
        Parameters:
         - partitions
         - requestContext

        """
        self.send_tablePartitionsCallback(partitions, requestContext)
        self.recv_tablePartitionsCallback()

    def send_tablePartitionsCallback(self, partitions, requestContext):
        self._oprot.writeMessageBegin("tablePartitionsCallback", TMessageType.CALL, self._seqid)
        args = tablePartitionsCallback_args()
        args.partitions = partitions
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tablePartitionsCallback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tablePartitionsCallback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def deltaTablePartitionsCallback(self, deltaTableChangeResponse, requestContext):
        """
        Parameters:
         - deltaTableChangeResponse
         - requestContext

        """
        self.send_deltaTablePartitionsCallback(deltaTableChangeResponse, requestContext)
        self.recv_deltaTablePartitionsCallback()

    def send_deltaTablePartitionsCallback(self, deltaTableChangeResponse, requestContext):
        self._oprot.writeMessageBegin(
            "deltaTablePartitionsCallback", TMessageType.CALL, self._seqid
        )
        args = deltaTablePartitionsCallback_args()
        args.deltaTableChangeResponse = deltaTableChangeResponse
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deltaTablePartitionsCallback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deltaTablePartitionsCallback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def tablePartitionFilesCallback(self, mapPartitionNameAndFileMetadatas, requestContext):
        """
        Parameters:
         - mapPartitionNameAndFileMetadatas
         - requestContext

        """
        self.send_tablePartitionFilesCallback(mapPartitionNameAndFileMetadatas, requestContext)
        self.recv_tablePartitionFilesCallback()

    def send_tablePartitionFilesCallback(self, mapPartitionNameAndFileMetadatas, requestContext):
        self._oprot.writeMessageBegin("tablePartitionFilesCallback", TMessageType.CALL, self._seqid)
        args = tablePartitionFilesCallback_args()
        args.mapPartitionNameAndFileMetadatas = mapPartitionNameAndFileMetadatas
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tablePartitionFilesCallback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tablePartitionFilesCallback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def tableFileMetadataCallback(self, listFileMetadata, requestContext):
        """
        Parameters:
         - listFileMetadata
         - requestContext

        """
        self.send_tableFileMetadataCallback(listFileMetadata, requestContext)
        self.recv_tableFileMetadataCallback()

    def send_tableFileMetadataCallback(self, listFileMetadata, requestContext):
        self._oprot.writeMessageBegin("tableFileMetadataCallback", TMessageType.CALL, self._seqid)
        args = tableFileMetadataCallback_args()
        args.listFileMetadata = listFileMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tableFileMetadataCallback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tableFileMetadataCallback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def getAdditionalDataCallback(self, mapPartitiontoDeletionVectors, requestContext):
        """
        Parameters:
         - mapPartitiontoDeletionVectors
         - requestContext

        """
        self.send_getAdditionalDataCallback(mapPartitiontoDeletionVectors, requestContext)
        self.recv_getAdditionalDataCallback()

    def send_getAdditionalDataCallback(self, mapPartitiontoDeletionVectors, requestContext):
        self._oprot.writeMessageBegin("getAdditionalDataCallback", TMessageType.CALL, self._seqid)
        args = getAdditionalDataCallback_args()
        args.mapPartitiontoDeletionVectors = mapPartitiontoDeletionVectors
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAdditionalDataCallback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAdditionalDataCallback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def upsertDBNames(self, catalogName, dbNames):
        """
        Parameters:
         - catalogName
         - dbNames

        """
        self.send_upsertDBNames(catalogName, dbNames)
        self.recv_upsertDBNames()

    def send_upsertDBNames(self, catalogName, dbNames):
        self._oprot.writeMessageBegin("upsertDBNames", TMessageType.CALL, self._seqid)
        args = upsertDBNames_args()
        args.catalogName = catalogName
        args.dbNames = dbNames
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_upsertDBNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = upsertDBNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def upsertTableNames(self, catalogName, dbName, tableNames):
        """
        Parameters:
         - catalogName
         - dbName
         - tableNames

        """
        self.send_upsertTableNames(catalogName, dbName, tableNames)
        self.recv_upsertTableNames()

    def send_upsertTableNames(self, catalogName, dbName, tableNames):
        self._oprot.writeMessageBegin("upsertTableNames", TMessageType.CALL, self._seqid)
        args = upsertTableNames_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableNames = tableNames
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_upsertTableNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = upsertTableNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def upsertTables(self, catalogName, dbName, tables):
        """
        Parameters:
         - catalogName
         - dbName
         - tables

        """
        self.send_upsertTables(catalogName, dbName, tables)
        self.recv_upsertTables()

    def send_upsertTables(self, catalogName, dbName, tables):
        self._oprot.writeMessageBegin("upsertTables", TMessageType.CALL, self._seqid)
        args = upsertTables_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tables = tables
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_upsertTables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = upsertTables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def upsertTableStatistics(self, catalogName, dbName, tableName, tableStats):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - tableStats

        """
        self.send_upsertTableStatistics(catalogName, dbName, tableName, tableStats)
        self.recv_upsertTableStatistics()

    def send_upsertTableStatistics(self, catalogName, dbName, tableName, tableStats):
        self._oprot.writeMessageBegin("upsertTableStatistics", TMessageType.CALL, self._seqid)
        args = upsertTableStatistics_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.tableStats = tableStats
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_upsertTableStatistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = upsertTableStatistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def upsertTablePartitions(self, catalogName, dbName, tableName, partitions):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - partitions

        """
        self.send_upsertTablePartitions(catalogName, dbName, tableName, partitions)
        self.recv_upsertTablePartitions()

    def send_upsertTablePartitions(self, catalogName, dbName, tableName, partitions):
        self._oprot.writeMessageBegin("upsertTablePartitions", TMessageType.CALL, self._seqid)
        args = upsertTablePartitions_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.partitions = partitions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_upsertTablePartitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = upsertTablePartitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def upsertTablePartitionFiles(
        self, catalogName, dbName, tableName, mapPartitionNameAndFileMetadata
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - mapPartitionNameAndFileMetadata

        """
        self.send_upsertTablePartitionFiles(
            catalogName, dbName, tableName, mapPartitionNameAndFileMetadata
        )
        self.recv_upsertTablePartitionFiles()

    def send_upsertTablePartitionFiles(
        self, catalogName, dbName, tableName, mapPartitionNameAndFileMetadata
    ):
        self._oprot.writeMessageBegin("upsertTablePartitionFiles", TMessageType.CALL, self._seqid)
        args = upsertTablePartitionFiles_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.mapPartitionNameAndFileMetadata = mapPartitionNameAndFileMetadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_upsertTablePartitionFiles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = upsertTablePartitionFiles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def upsertTableFileMetadata(self, catalogName, dbName, tableName, fileMetadata):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - fileMetadata

        """
        self.send_upsertTableFileMetadata(catalogName, dbName, tableName, fileMetadata)
        self.recv_upsertTableFileMetadata()

    def send_upsertTableFileMetadata(self, catalogName, dbName, tableName, fileMetadata):
        self._oprot.writeMessageBegin("upsertTableFileMetadata", TMessageType.CALL, self._seqid)
        args = upsertTableFileMetadata_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.fileMetadata = fileMetadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_upsertTableFileMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = upsertTableFileMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def getCatalogDump(self, catalogDumpRequest):
        """
        Parameters:
         - catalogDumpRequest

        """
        self.send_getCatalogDump(catalogDumpRequest)
        return self.recv_getCatalogDump()

    def send_getCatalogDump(self, catalogDumpRequest):
        self._oprot.writeMessageBegin("getCatalogDump", TMessageType.CALL, self._seqid)
        args = getCatalogDump_args()
        args.catalogDumpRequest = catalogDumpRequest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCatalogDump(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCatalogDump_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getCatalogDump failed: unknown result"
        )

    def analyzeTable(self, catalogName, dbName, tableName, columnNames, requestId):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - columnNames
         - requestId

        """
        self.send_analyzeTable(catalogName, dbName, tableName, columnNames, requestId)
        self.recv_analyzeTable()

    def send_analyzeTable(self, catalogName, dbName, tableName, columnNames, requestId):
        self._oprot.writeMessageBegin("analyzeTable", TMessageType.CALL, self._seqid)
        args = analyzeTable_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.columnNames = columnNames
        args.requestId = requestId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_analyzeTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = analyzeTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def getAnalyzedTableInfo(self, catalogName, dbName, tableName, requestId):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - requestId

        """
        self.send_getAnalyzedTableInfo(catalogName, dbName, tableName, requestId)
        return self.recv_getAnalyzedTableInfo()

    def send_getAnalyzedTableInfo(self, catalogName, dbName, tableName, requestId):
        self._oprot.writeMessageBegin("getAnalyzedTableInfo", TMessageType.CALL, self._seqid)
        args = getAnalyzedTableInfo_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.requestId = requestId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAnalyzedTableInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAnalyzedTableInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getAnalyzedTableInfo failed: unknown result"
        )

    def getHistoricalStats(self):
        self.send_getHistoricalStats()
        return self.recv_getHistoricalStats()

    def send_getHistoricalStats(self):
        self._oprot.writeMessageBegin("getHistoricalStats", TMessageType.CALL, self._seqid)
        args = getHistoricalStats_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getHistoricalStats(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getHistoricalStats_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getHistoricalStats failed: unknown result"
        )

    def updateHBOCacheInStorage(self, stats):
        """
        Parameters:
         - stats

        """
        self.send_updateHBOCacheInStorage(stats)

    def send_updateHBOCacheInStorage(self, stats):
        self._oprot.writeMessageBegin("updateHBOCacheInStorage", TMessageType.ONEWAY, self._seqid)
        args = updateHBOCacheInStorage_args()
        args.stats = stats
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def createView(self, catalogName, databaseName, tableName, requestId, table):
        """
        Parameters:
         - catalogName
         - databaseName
         - tableName
         - requestId
         - table

        """
        self.send_createView(catalogName, databaseName, tableName, requestId, table)
        self.recv_createView()

    def send_createView(self, catalogName, databaseName, tableName, requestId, table):
        self._oprot.writeMessageBegin("createView", TMessageType.CALL, self._seqid)
        args = createView_args()
        args.catalogName = catalogName
        args.databaseName = databaseName
        args.tableName = tableName
        args.requestId = requestId
        args.table = table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def updateView(self, catalogName, databaseName, tableName, table, requestId):
        """
        Parameters:
         - catalogName
         - databaseName
         - tableName
         - table
         - requestId

        """
        self.send_updateView(catalogName, databaseName, tableName, table, requestId)
        self.recv_updateView()

    def send_updateView(self, catalogName, databaseName, tableName, table, requestId):
        self._oprot.writeMessageBegin("updateView", TMessageType.CALL, self._seqid)
        args = updateView_args()
        args.catalogName = catalogName
        args.databaseName = databaseName
        args.tableName = tableName
        args.table = table
        args.requestId = requestId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def alterView(self, catalogName, databaseName, tableName, requestId, table):
        """
        Parameters:
         - catalogName
         - databaseName
         - tableName
         - requestId
         - table

        """
        self.send_alterView(catalogName, databaseName, tableName, requestId, table)
        self.recv_alterView()

    def send_alterView(self, catalogName, databaseName, tableName, requestId, table):
        self._oprot.writeMessageBegin("alterView", TMessageType.CALL, self._seqid)
        args = alterView_args()
        args.catalogName = catalogName
        args.databaseName = databaseName
        args.tableName = tableName
        args.requestId = requestId
        args.table = table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alterView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alterView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def dropView(self, catalogName, databaseName, tableName, requestId):
        """
        Parameters:
         - catalogName
         - databaseName
         - tableName
         - requestId

        """
        self.send_dropView(catalogName, databaseName, tableName, requestId)
        self.recv_dropView()

    def send_dropView(self, catalogName, databaseName, tableName, requestId):
        self._oprot.writeMessageBegin("dropView", TMessageType.CALL, self._seqid)
        args = dropView_args()
        args.catalogName = catalogName
        args.databaseName = databaseName
        args.tableName = tableName
        args.requestId = requestId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dropView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dropView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getConnectionMetadata"] = Processor.process_getConnectionMetadata
        self._processMap["getCatalogNames"] = Processor.process_getCatalogNames
        self._processMap["getDBNames"] = Processor.process_getDBNames
        self._processMap["getTableNames"] = Processor.process_getTableNames
        self._processMap["getColumns"] = Processor.process_getColumns
        self._processMap["getColumnsForTables"] = Processor.process_getColumnsForTables
        self._processMap["getColumnsForAllTablesInDb"] = (
            Processor.process_getColumnsForAllTablesInDb
        )
        self._processMap["getColumnsForAllTablesInCatalog"] = (
            Processor.process_getColumnsForAllTablesInCatalog
        )
        self._processMap["getCatalogNamesV2"] = Processor.process_getCatalogNamesV2
        self._processMap["getDBNamesV2"] = Processor.process_getDBNamesV2
        self._processMap["getTableNamesV2"] = Processor.process_getTableNamesV2
        self._processMap["getColumnsV2"] = Processor.process_getColumnsV2
        self._processMap["getColumnsForTablesV2"] = Processor.process_getColumnsForTablesV2
        self._processMap["getColumnsForAllTablesInDbV2"] = (
            Processor.process_getColumnsForAllTablesInDbV2
        )
        self._processMap["getColumnsForAllTablesInCatalogV2"] = (
            Processor.process_getColumnsForAllTablesInCatalogV2
        )
        self._processMap["getTableMetadata"] = Processor.process_getTableMetadata
        self._processMap["getDBObjects"] = Processor.process_getDBObjects
        self._processMap["getDBObjectsV2"] = Processor.process_getDBObjectsV2
        self._processMap["getTableStatistics"] = Processor.process_getTableStatistics
        self._processMap["getTableStatisticsV2"] = Processor.process_getTableStatisticsV2
        self._processMap["getTablePartitionsAtVersion"] = (
            Processor.process_getTablePartitionsAtVersion
        )
        self._processMap["getTablePartitionFileAndMetadataAtVersion"] = (
            Processor.process_getTablePartitionFileAndMetadataAtVersion
        )
        self._processMap["getTablePartitions"] = Processor.process_getTablePartitions
        self._processMap["getTablePartitionFileAndMetadata"] = (
            Processor.process_getTablePartitionFileAndMetadata
        )
        self._processMap["putFileMetadata"] = Processor.process_putFileMetadata
        self._processMap["bulkAddCatalogs"] = Processor.process_bulkAddCatalogs
        self._processMap["refreshCatalog"] = Processor.process_refreshCatalog
        self._processMap["getAddOrRefreshCatalogResponse"] = (
            Processor.process_getAddOrRefreshCatalogResponse
        )
        self._processMap["forceBulkAddCatalogs"] = Processor.process_forceBulkAddCatalogs
        self._processMap["refreshDBs"] = Processor.process_refreshDBs
        self._processMap["getRefreshDBsResponse"] = Processor.process_getRefreshDBsResponse
        self._processMap["dropCatalog"] = Processor.process_dropCatalog
        self._processMap["dBNamesCallback"] = Processor.process_dBNamesCallback
        self._processMap["tableNamesCallback"] = Processor.process_tableNamesCallback
        self._processMap["tablesCallback"] = Processor.process_tablesCallback
        self._processMap["tableStatisticsCallback"] = Processor.process_tableStatisticsCallback
        self._processMap["tablePartitionsCallback"] = Processor.process_tablePartitionsCallback
        self._processMap["deltaTablePartitionsCallback"] = (
            Processor.process_deltaTablePartitionsCallback
        )
        self._processMap["tablePartitionFilesCallback"] = (
            Processor.process_tablePartitionFilesCallback
        )
        self._processMap["tableFileMetadataCallback"] = Processor.process_tableFileMetadataCallback
        self._processMap["getAdditionalDataCallback"] = Processor.process_getAdditionalDataCallback
        self._processMap["upsertDBNames"] = Processor.process_upsertDBNames
        self._processMap["upsertTableNames"] = Processor.process_upsertTableNames
        self._processMap["upsertTables"] = Processor.process_upsertTables
        self._processMap["upsertTableStatistics"] = Processor.process_upsertTableStatistics
        self._processMap["upsertTablePartitions"] = Processor.process_upsertTablePartitions
        self._processMap["upsertTablePartitionFiles"] = Processor.process_upsertTablePartitionFiles
        self._processMap["upsertTableFileMetadata"] = Processor.process_upsertTableFileMetadata
        self._processMap["getCatalogDump"] = Processor.process_getCatalogDump
        self._processMap["analyzeTable"] = Processor.process_analyzeTable
        self._processMap["getAnalyzedTableInfo"] = Processor.process_getAnalyzedTableInfo
        self._processMap["getHistoricalStats"] = Processor.process_getHistoricalStats
        self._processMap["updateHBOCacheInStorage"] = Processor.process_updateHBOCacheInStorage
        self._processMap["createView"] = Processor.process_createView
        self._processMap["updateView"] = Processor.process_updateView
        self._processMap["alterView"] = Processor.process_alterView
        self._processMap["dropView"] = Processor.process_dropView
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(
                TApplicationException.UNKNOWN_METHOD, "Unknown function %s" % (name)
            )
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getConnectionMetadata(self, seqid, iprot, oprot):
        args = getConnectionMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getConnectionMetadata_result()
        try:
            result.success = self._handler.getConnectionMetadata(args.catalogName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getConnectionMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCatalogNames(self, seqid, iprot, oprot):
        args = getCatalogNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCatalogNames_result()
        try:
            result.success = self._handler.getCatalogNames()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getCatalogNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDBNames(self, seqid, iprot, oprot):
        args = getDBNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDBNames_result()
        try:
            result.success = self._handler.getDBNames(args.catalogName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getDBNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableNames(self, seqid, iprot, oprot):
        args = getTableNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableNames_result()
        try:
            result.success = self._handler.getTableNames(args.catalogName, args.dbName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getColumns(self, seqid, iprot, oprot):
        args = getColumns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getColumns_result()
        try:
            result.success = self._handler.getColumns(args.catalogName, args.dbName, args.tableName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getColumns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getColumnsForTables(self, seqid, iprot, oprot):
        args = getColumnsForTables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getColumnsForTables_result()
        try:
            result.success = self._handler.getColumnsForTables(
                args.catalogName, args.dbName, args.tableName
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getColumnsForTables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getColumnsForAllTablesInDb(self, seqid, iprot, oprot):
        args = getColumnsForAllTablesInDb_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getColumnsForAllTablesInDb_result()
        try:
            result.success = self._handler.getColumnsForAllTablesInDb(args.catalogName, args.dbName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getColumnsForAllTablesInDb", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getColumnsForAllTablesInCatalog(self, seqid, iprot, oprot):
        args = getColumnsForAllTablesInCatalog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getColumnsForAllTablesInCatalog_result()
        try:
            result.success = self._handler.getColumnsForAllTablesInCatalog(args.catalogName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getColumnsForAllTablesInCatalog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCatalogNamesV2(self, seqid, iprot, oprot):
        args = getCatalogNamesV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCatalogNamesV2_result()
        try:
            result.success = self._handler.getCatalogNamesV2(args.userContext)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getCatalogNamesV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDBNamesV2(self, seqid, iprot, oprot):
        args = getDBNamesV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDBNamesV2_result()
        try:
            result.success = self._handler.getDBNamesV2(args.userContext, args.catalogName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getDBNamesV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableNamesV2(self, seqid, iprot, oprot):
        args = getTableNamesV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableNamesV2_result()
        try:
            result.success = self._handler.getTableNamesV2(
                args.userContext, args.catalogName, args.dbName
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableNamesV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getColumnsV2(self, seqid, iprot, oprot):
        args = getColumnsV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getColumnsV2_result()
        try:
            result.success = self._handler.getColumnsV2(
                args.userContext, args.catalogName, args.dbName, args.tableName
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getColumnsV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getColumnsForTablesV2(self, seqid, iprot, oprot):
        args = getColumnsForTablesV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getColumnsForTablesV2_result()
        try:
            result.success = self._handler.getColumnsForTablesV2(
                args.userContext, args.catalogName, args.dbName, args.tableName
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getColumnsForTablesV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getColumnsForAllTablesInDbV2(self, seqid, iprot, oprot):
        args = getColumnsForAllTablesInDbV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getColumnsForAllTablesInDbV2_result()
        try:
            result.success = self._handler.getColumnsForAllTablesInDbV2(
                args.userContext, args.catalogName, args.dbName
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getColumnsForAllTablesInDbV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getColumnsForAllTablesInCatalogV2(self, seqid, iprot, oprot):
        args = getColumnsForAllTablesInCatalogV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getColumnsForAllTablesInCatalogV2_result()
        try:
            result.success = self._handler.getColumnsForAllTablesInCatalogV2(
                args.userContext, args.catalogName
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getColumnsForAllTablesInCatalogV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableMetadata(self, seqid, iprot, oprot):
        args = getTableMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableMetadata_result()
        try:
            result.success = self._handler.getTableMetadata(
                args.catalogName, args.dbName, args.tableName, args.requestId
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDBObjects(self, seqid, iprot, oprot):
        args = getDBObjects_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDBObjects_result()
        try:
            result.success = self._handler.getDBObjects(args.catalogName, args.dbName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getDBObjects", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDBObjectsV2(self, seqid, iprot, oprot):
        args = getDBObjectsV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDBObjectsV2_result()
        try:
            result.success = self._handler.getDBObjectsV2(
                args.userContext, args.catalogName, args.dbName
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getDBObjectsV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableStatistics(self, seqid, iprot, oprot):
        args = getTableStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableStatistics_result()
        try:
            result.success = self._handler.getTableStatistics(
                args.catalogName, args.dbName, args.tableName, args.requestId
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableStatistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableStatisticsV2(self, seqid, iprot, oprot):
        args = getTableStatisticsV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableStatisticsV2_result()
        try:
            result.success = self._handler.getTableStatisticsV2(
                args.catalogName, args.dbName, args.tableName, args.requestId
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableStatisticsV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTablePartitionsAtVersion(self, seqid, iprot, oprot):
        args = getTablePartitionsAtVersion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTablePartitionsAtVersion_result()
        try:
            result.success = self._handler.getTablePartitionsAtVersion(
                args.catalogName, args.dbName, args.tableName, args.requestId, args.timeTravelInfo
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTablePartitionsAtVersion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTablePartitionFileAndMetadataAtVersion(self, seqid, iprot, oprot):
        args = getTablePartitionFileAndMetadataAtVersion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTablePartitionFileAndMetadataAtVersion_result()
        try:
            result.success = self._handler.getTablePartitionFileAndMetadataAtVersion(
                args.catalogName,
                args.dbName,
                args.tableName,
                args.partitions,
                args.requestId,
                args.timeTravelInfo,
                args.shouldGetFileMetadata,
                args.columnsWithStats,
                args.getStatsForAllColumns,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTablePartitionFileAndMetadataAtVersion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTablePartitions(self, seqid, iprot, oprot):
        args = getTablePartitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTablePartitions_result()
        try:
            result.success = self._handler.getTablePartitions(
                args.catalogName,
                args.dbName,
                args.tableName,
                args.requestId,
                args.forceRefresh,
                args.lastUpdateTimeFromCache,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTablePartitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTablePartitionFileAndMetadata(self, seqid, iprot, oprot):
        args = getTablePartitionFileAndMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTablePartitionFileAndMetadata_result()
        try:
            result.success = self._handler.getTablePartitionFileAndMetadata(
                args.catalogName,
                args.dbName,
                args.tableName,
                args.partitions,
                args.requestId,
                args.forcerefresh,
                args.shouldGetFileMetadata,
                args.columnsWithStats,
                args.getStatsForAllColumns,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTablePartitionFileAndMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_putFileMetadata(self, seqid, iprot, oprot):
        args = putFileMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.putFileMetadata(args.partFiles, args.requestId)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception("Exception in oneway handler")

    def process_bulkAddCatalogs(self, seqid, iprot, oprot):
        args = bulkAddCatalogs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = bulkAddCatalogs_result()
        try:
            result.success = self._handler.bulkAddCatalogs(args.catalogsJson)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("bulkAddCatalogs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_refreshCatalog(self, seqid, iprot, oprot):
        args = refreshCatalog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = refreshCatalog_result()
        try:
            result.success = self._handler.refreshCatalog(args.catalogName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("refreshCatalog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAddOrRefreshCatalogResponse(self, seqid, iprot, oprot):
        args = getAddOrRefreshCatalogResponse_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAddOrRefreshCatalogResponse_result()
        try:
            result.success = self._handler.getAddOrRefreshCatalogResponse(args.catalogName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getAddOrRefreshCatalogResponse", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forceBulkAddCatalogs(self, seqid, iprot, oprot):
        args = forceBulkAddCatalogs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forceBulkAddCatalogs_result()
        try:
            result.success = self._handler.forceBulkAddCatalogs()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("forceBulkAddCatalogs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_refreshDBs(self, seqid, iprot, oprot):
        args = refreshDBs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = refreshDBs_result()
        try:
            result.success = self._handler.refreshDBs(args.catalogName, args.dbName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("refreshDBs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRefreshDBsResponse(self, seqid, iprot, oprot):
        args = getRefreshDBsResponse_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRefreshDBsResponse_result()
        try:
            result.success = self._handler.getRefreshDBsResponse(args.catalogName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getRefreshDBsResponse", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dropCatalog(self, seqid, iprot, oprot):
        args = dropCatalog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dropCatalog_result()
        try:
            self._handler.dropCatalog(args.catalogName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("dropCatalog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dBNamesCallback(self, seqid, iprot, oprot):
        args = dBNamesCallback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dBNamesCallback_result()
        try:
            self._handler.dBNamesCallback(args.dbNames, args.requestContext)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("dBNamesCallback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tableNamesCallback(self, seqid, iprot, oprot):
        args = tableNamesCallback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tableNamesCallback_result()
        try:
            self._handler.tableNamesCallback(args.tableNames, args.requestContext)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("tableNamesCallback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tablesCallback(self, seqid, iprot, oprot):
        args = tablesCallback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tablesCallback_result()
        try:
            self._handler.tablesCallback(args.listTablesCallback, args.requestContext)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("tablesCallback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tableStatisticsCallback(self, seqid, iprot, oprot):
        args = tableStatisticsCallback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tableStatisticsCallback_result()
        try:
            self._handler.tableStatisticsCallback(args.tableStats, args.requestContext)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("tableStatisticsCallback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tablePartitionsCallback(self, seqid, iprot, oprot):
        args = tablePartitionsCallback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tablePartitionsCallback_result()
        try:
            self._handler.tablePartitionsCallback(args.partitions, args.requestContext)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("tablePartitionsCallback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deltaTablePartitionsCallback(self, seqid, iprot, oprot):
        args = deltaTablePartitionsCallback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deltaTablePartitionsCallback_result()
        try:
            self._handler.deltaTablePartitionsCallback(
                args.deltaTableChangeResponse, args.requestContext
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("deltaTablePartitionsCallback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tablePartitionFilesCallback(self, seqid, iprot, oprot):
        args = tablePartitionFilesCallback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tablePartitionFilesCallback_result()
        try:
            self._handler.tablePartitionFilesCallback(
                args.mapPartitionNameAndFileMetadatas, args.requestContext
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("tablePartitionFilesCallback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tableFileMetadataCallback(self, seqid, iprot, oprot):
        args = tableFileMetadataCallback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tableFileMetadataCallback_result()
        try:
            self._handler.tableFileMetadataCallback(args.listFileMetadata, args.requestContext)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("tableFileMetadataCallback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAdditionalDataCallback(self, seqid, iprot, oprot):
        args = getAdditionalDataCallback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAdditionalDataCallback_result()
        try:
            self._handler.getAdditionalDataCallback(
                args.mapPartitiontoDeletionVectors, args.requestContext
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getAdditionalDataCallback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_upsertDBNames(self, seqid, iprot, oprot):
        args = upsertDBNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = upsertDBNames_result()
        try:
            self._handler.upsertDBNames(args.catalogName, args.dbNames)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("upsertDBNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_upsertTableNames(self, seqid, iprot, oprot):
        args = upsertTableNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = upsertTableNames_result()
        try:
            self._handler.upsertTableNames(args.catalogName, args.dbName, args.tableNames)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("upsertTableNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_upsertTables(self, seqid, iprot, oprot):
        args = upsertTables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = upsertTables_result()
        try:
            self._handler.upsertTables(args.catalogName, args.dbName, args.tables)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("upsertTables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_upsertTableStatistics(self, seqid, iprot, oprot):
        args = upsertTableStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = upsertTableStatistics_result()
        try:
            self._handler.upsertTableStatistics(
                args.catalogName, args.dbName, args.tableName, args.tableStats
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("upsertTableStatistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_upsertTablePartitions(self, seqid, iprot, oprot):
        args = upsertTablePartitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = upsertTablePartitions_result()
        try:
            self._handler.upsertTablePartitions(
                args.catalogName, args.dbName, args.tableName, args.partitions
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("upsertTablePartitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_upsertTablePartitionFiles(self, seqid, iprot, oprot):
        args = upsertTablePartitionFiles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = upsertTablePartitionFiles_result()
        try:
            self._handler.upsertTablePartitionFiles(
                args.catalogName, args.dbName, args.tableName, args.mapPartitionNameAndFileMetadata
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("upsertTablePartitionFiles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_upsertTableFileMetadata(self, seqid, iprot, oprot):
        args = upsertTableFileMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = upsertTableFileMetadata_result()
        try:
            self._handler.upsertTableFileMetadata(
                args.catalogName, args.dbName, args.tableName, args.fileMetadata
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("upsertTableFileMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCatalogDump(self, seqid, iprot, oprot):
        args = getCatalogDump_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCatalogDump_result()
        try:
            result.success = self._handler.getCatalogDump(args.catalogDumpRequest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getCatalogDump", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_analyzeTable(self, seqid, iprot, oprot):
        args = analyzeTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = analyzeTable_result()
        try:
            self._handler.analyzeTable(
                args.catalogName, args.dbName, args.tableName, args.columnNames, args.requestId
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("analyzeTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAnalyzedTableInfo(self, seqid, iprot, oprot):
        args = getAnalyzedTableInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAnalyzedTableInfo_result()
        try:
            result.success = self._handler.getAnalyzedTableInfo(
                args.catalogName, args.dbName, args.tableName, args.requestId
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getAnalyzedTableInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getHistoricalStats(self, seqid, iprot, oprot):
        args = getHistoricalStats_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getHistoricalStats_result()
        try:
            result.success = self._handler.getHistoricalStats()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getHistoricalStats", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateHBOCacheInStorage(self, seqid, iprot, oprot):
        args = updateHBOCacheInStorage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.updateHBOCacheInStorage(args.stats)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception("Exception in oneway handler")

    def process_createView(self, seqid, iprot, oprot):
        args = createView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createView_result()
        try:
            self._handler.createView(
                args.catalogName, args.databaseName, args.tableName, args.requestId, args.table
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("createView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateView(self, seqid, iprot, oprot):
        args = updateView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateView_result()
        try:
            self._handler.updateView(
                args.catalogName, args.databaseName, args.tableName, args.table, args.requestId
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("updateView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alterView(self, seqid, iprot, oprot):
        args = alterView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alterView_result()
        try:
            self._handler.alterView(
                args.catalogName, args.databaseName, args.tableName, args.requestId, args.table
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("alterView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dropView(self, seqid, iprot, oprot):
        args = dropView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dropView_result()
        try:
            self._handler.dropView(
                args.catalogName, args.databaseName, args.tableName, args.requestId
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except StorageServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("dropView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES


class getConnectionMetadata_args(object):
    """
    Attributes:
     - catalogName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
    ):
        self.catalogName = catalogName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getConnectionMetadata_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getConnectionMetadata_args)
getConnectionMetadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
)


class getConnectionMetadata_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = guardrail.e6_schema_service.ttypes.ConnectionMetadata()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getConnectionMetadata_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getConnectionMetadata_result)
getConnectionMetadata_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [guardrail.e6_schema_service.ttypes.ConnectionMetadata, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getCatalogNames_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getCatalogNames_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getCatalogNames_args)
getCatalogNames_args.thrift_spec = ()


class getCatalogNames_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype134, _size131) = iprot.readListBegin()
                    for _i135 in range(_size131):
                        _elem136 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem136)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getCatalogNames_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter137 in self.success:
                oprot.writeString(iter137.encode("utf-8") if sys.version_info[0] == 2 else iter137)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getCatalogNames_result)
getCatalogNames_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getDBNames_args(object):
    """
    Attributes:
     - catalogName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
    ):
        self.catalogName = catalogName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBNames_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBNames_args)
getDBNames_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
)


class getDBNames_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype141, _size138) = iprot.readListBegin()
                    for _i142 in range(_size138):
                        _elem143 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem143)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBNames_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter144 in self.success:
                oprot.writeString(iter144.encode("utf-8") if sys.version_info[0] == 2 else iter144)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBNames_result)
getDBNames_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getTableNames_args(object):
    """
    Attributes:
     - catalogName
     - dbName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableNames_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableNames_args)
getTableNames_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
)


class getTableNames_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype148, _size145) = iprot.readListBegin()
                    for _i149 in range(_size145):
                        _elem150 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem150)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableNames_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter151 in self.success:
                oprot.writeString(iter151.encode("utf-8") if sys.version_info[0] == 2 else iter151)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableNames_result)
getTableNames_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getColumns_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumns_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumns_args)
getColumns_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
)


class getColumns_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype155, _size152) = iprot.readListBegin()
                    for _i156 in range(_size152):
                        _elem157 = FieldMetadata()
                        _elem157.read(iprot)
                        self.success.append(_elem157)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumns_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter158 in self.success:
                iter158.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumns_result)
getColumns_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [FieldMetadata, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getColumnsForTables_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tableName = []
                    (_etype162, _size159) = iprot.readListBegin()
                    for _i163 in range(_size159):
                        _elem164 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.tableName.append(_elem164)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForTables_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.tableName))
            for iter165 in self.tableName:
                oprot.writeString(iter165.encode("utf-8") if sys.version_info[0] == 2 else iter165)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForTables_args)
getColumnsForTables_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "tableName",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
)


class getColumnsForTables_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CatalogMetadata()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForTables_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForTables_result)
getColumnsForTables_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [CatalogMetadata, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getColumnsForAllTablesInDb_args(object):
    """
    Attributes:
     - catalogName
     - dbName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForAllTablesInDb_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForAllTablesInDb_args)
getColumnsForAllTablesInDb_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
)


class getColumnsForAllTablesInDb_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CatalogMetadata()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForAllTablesInDb_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForAllTablesInDb_result)
getColumnsForAllTablesInDb_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [CatalogMetadata, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getColumnsForAllTablesInCatalog_args(object):
    """
    Attributes:
     - catalogName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
    ):
        self.catalogName = catalogName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForAllTablesInCatalog_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForAllTablesInCatalog_args)
getColumnsForAllTablesInCatalog_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
)


class getColumnsForAllTablesInCatalog_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype169, _size166) = iprot.readListBegin()
                    for _i170 in range(_size166):
                        _elem171 = CatalogMetadata()
                        _elem171.read(iprot)
                        self.success.append(_elem171)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForAllTablesInCatalog_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter172 in self.success:
                iter172.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForAllTablesInCatalog_result)
getColumnsForAllTablesInCatalog_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [CatalogMetadata, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getCatalogNamesV2_args(object):
    """
    Attributes:
     - userContext

    """

    thrift_spec = None

    def __init__(
        self,
        userContext=None,
    ):
        self.userContext = userContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userContext = UserContext()
                    self.userContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getCatalogNamesV2_args")
        if self.userContext is not None:
            oprot.writeFieldBegin("userContext", TType.STRUCT, 1)
            self.userContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getCatalogNamesV2_args)
getCatalogNamesV2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "userContext",
        [UserContext, None],
        None,
    ),  # 1
)


class getCatalogNamesV2_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype176, _size173) = iprot.readListBegin()
                    for _i177 in range(_size173):
                        _elem178 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem178)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getCatalogNamesV2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter179 in self.success:
                oprot.writeString(iter179.encode("utf-8") if sys.version_info[0] == 2 else iter179)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getCatalogNamesV2_result)
getCatalogNamesV2_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getDBNamesV2_args(object):
    """
    Attributes:
     - userContext
     - catalogName

    """

    thrift_spec = None

    def __init__(
        self,
        userContext=None,
        catalogName=None,
    ):
        self.userContext = userContext
        self.catalogName = catalogName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userContext = UserContext()
                    self.userContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBNamesV2_args")
        if self.userContext is not None:
            oprot.writeFieldBegin("userContext", TType.STRUCT, 1)
            self.userContext.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 2)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBNamesV2_args)
getDBNamesV2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "userContext",
        [UserContext, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 2
)


class getDBNamesV2_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype183, _size180) = iprot.readListBegin()
                    for _i184 in range(_size180):
                        _elem185 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem185)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBNamesV2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter186 in self.success:
                oprot.writeString(iter186.encode("utf-8") if sys.version_info[0] == 2 else iter186)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBNamesV2_result)
getDBNamesV2_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getTableNamesV2_args(object):
    """
    Attributes:
     - userContext
     - catalogName
     - dbName

    """

    thrift_spec = None

    def __init__(
        self,
        userContext=None,
        catalogName=None,
        dbName=None,
    ):
        self.userContext = userContext
        self.catalogName = catalogName
        self.dbName = dbName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userContext = UserContext()
                    self.userContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableNamesV2_args")
        if self.userContext is not None:
            oprot.writeFieldBegin("userContext", TType.STRUCT, 1)
            self.userContext.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 2)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 3)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableNamesV2_args)
getTableNamesV2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "userContext",
        [UserContext, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 3
)


class getTableNamesV2_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype190, _size187) = iprot.readListBegin()
                    for _i191 in range(_size187):
                        _elem192 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem192)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableNamesV2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter193 in self.success:
                oprot.writeString(iter193.encode("utf-8") if sys.version_info[0] == 2 else iter193)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableNamesV2_result)
getTableNamesV2_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getColumnsV2_args(object):
    """
    Attributes:
     - userContext
     - catalogName
     - dbName
     - tableName

    """

    thrift_spec = None

    def __init__(
        self,
        userContext=None,
        catalogName=None,
        dbName=None,
        tableName=None,
    ):
        self.userContext = userContext
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userContext = UserContext()
                    self.userContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsV2_args")
        if self.userContext is not None:
            oprot.writeFieldBegin("userContext", TType.STRUCT, 1)
            self.userContext.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 2)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 3)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 4)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsV2_args)
getColumnsV2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "userContext",
        [UserContext, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 4
)


class getColumnsV2_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype197, _size194) = iprot.readListBegin()
                    for _i198 in range(_size194):
                        _elem199 = FieldMetadata()
                        _elem199.read(iprot)
                        self.success.append(_elem199)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsV2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter200 in self.success:
                iter200.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsV2_result)
getColumnsV2_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [FieldMetadata, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getColumnsForTablesV2_args(object):
    """
    Attributes:
     - userContext
     - catalogName
     - dbName
     - tableName

    """

    thrift_spec = None

    def __init__(
        self,
        userContext=None,
        catalogName=None,
        dbName=None,
        tableName=None,
    ):
        self.userContext = userContext
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userContext = UserContext()
                    self.userContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.tableName = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.tableName.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForTablesV2_args")
        if self.userContext is not None:
            oprot.writeFieldBegin("userContext", TType.STRUCT, 1)
            self.userContext.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 2)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 3)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.tableName))
            for iter207 in self.tableName:
                oprot.writeString(iter207.encode("utf-8") if sys.version_info[0] == 2 else iter207)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForTablesV2_args)
getColumnsForTablesV2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "userContext",
        [UserContext, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "tableName",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 4
)


class getColumnsForTablesV2_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CatalogMetadata()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForTablesV2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForTablesV2_result)
getColumnsForTablesV2_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [CatalogMetadata, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getColumnsForAllTablesInDbV2_args(object):
    """
    Attributes:
     - userContext
     - catalogName
     - dbName

    """

    thrift_spec = None

    def __init__(
        self,
        userContext=None,
        catalogName=None,
        dbName=None,
    ):
        self.userContext = userContext
        self.catalogName = catalogName
        self.dbName = dbName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userContext = UserContext()
                    self.userContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForAllTablesInDbV2_args")
        if self.userContext is not None:
            oprot.writeFieldBegin("userContext", TType.STRUCT, 1)
            self.userContext.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 2)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 3)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForAllTablesInDbV2_args)
getColumnsForAllTablesInDbV2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "userContext",
        [UserContext, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 3
)


class getColumnsForAllTablesInDbV2_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CatalogMetadata()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForAllTablesInDbV2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForAllTablesInDbV2_result)
getColumnsForAllTablesInDbV2_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [CatalogMetadata, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getColumnsForAllTablesInCatalogV2_args(object):
    """
    Attributes:
     - userContext
     - catalogName

    """

    thrift_spec = None

    def __init__(
        self,
        userContext=None,
        catalogName=None,
    ):
        self.userContext = userContext
        self.catalogName = catalogName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userContext = UserContext()
                    self.userContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForAllTablesInCatalogV2_args")
        if self.userContext is not None:
            oprot.writeFieldBegin("userContext", TType.STRUCT, 1)
            self.userContext.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 2)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForAllTablesInCatalogV2_args)
getColumnsForAllTablesInCatalogV2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "userContext",
        [UserContext, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 2
)


class getColumnsForAllTablesInCatalogV2_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype211, _size208) = iprot.readListBegin()
                    for _i212 in range(_size208):
                        _elem213 = CatalogMetadata()
                        _elem213.read(iprot)
                        self.success.append(_elem213)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getColumnsForAllTablesInCatalogV2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter214 in self.success:
                iter214.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getColumnsForAllTablesInCatalogV2_result)
getColumnsForAllTablesInCatalogV2_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [CatalogMetadata, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getTableMetadata_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - requestId

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        requestId=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.requestId = requestId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableMetadata_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 4)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableMetadata_args)
getTableMetadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 4
)


class getTableMetadata_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableMetadata_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableMetadata_result)
getTableMetadata_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "BINARY",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getDBObjects_args(object):
    """
    Attributes:
     - catalogName
     - dbName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBObjects_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBObjects_args)
getDBObjects_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
)


class getDBObjects_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype218, _size215) = iprot.readListBegin()
                    for _i219 in range(_size215):
                        _elem220 = DBObject()
                        _elem220.read(iprot)
                        self.success.append(_elem220)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBObjects_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter221 in self.success:
                iter221.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBObjects_result)
getDBObjects_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [DBObject, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getDBObjectsV2_args(object):
    """
    Attributes:
     - userContext
     - catalogName
     - dbName

    """

    thrift_spec = None

    def __init__(
        self,
        userContext=None,
        catalogName=None,
        dbName=None,
    ):
        self.userContext = userContext
        self.catalogName = catalogName
        self.dbName = dbName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userContext = UserContext()
                    self.userContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBObjectsV2_args")
        if self.userContext is not None:
            oprot.writeFieldBegin("userContext", TType.STRUCT, 1)
            self.userContext.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 2)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 3)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBObjectsV2_args)
getDBObjectsV2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "userContext",
        [UserContext, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 3
)


class getDBObjectsV2_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype225, _size222) = iprot.readListBegin()
                    for _i226 in range(_size222):
                        _elem227 = DBObject()
                        _elem227.read(iprot)
                        self.success.append(_elem227)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBObjectsV2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter228 in self.success:
                iter228.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBObjectsV2_result)
getDBObjectsV2_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [DBObject, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getTableStatistics_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - requestId

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        requestId=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.requestId = requestId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableStatistics_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 5)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableStatistics_args)
getTableStatistics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    None,  # 4
    (
        5,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 5
)


class getTableStatistics_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableStatistics_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableStatistics_result)
getTableStatistics_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "BINARY",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getTableStatisticsV2_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - requestId

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        requestId=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.requestId = requestId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableStatisticsV2_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 5)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableStatisticsV2_args)
getTableStatisticsV2_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    None,  # 4
    (
        5,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 5
)


class getTableStatisticsV2_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TableStatistics()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableStatisticsV2_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableStatisticsV2_result)
getTableStatisticsV2_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [TableStatistics, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getTablePartitionsAtVersion_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - requestId
     - timeTravelInfo

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        requestId=None,
        timeTravelInfo=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.requestId = requestId
        self.timeTravelInfo = timeTravelInfo

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.timeTravelInfo = guardrail.e6_metadata_common.ttypes.TableVersionInfo()
                    self.timeTravelInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitionsAtVersion_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 4)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        if self.timeTravelInfo is not None:
            oprot.writeFieldBegin("timeTravelInfo", TType.STRUCT, 5)
            self.timeTravelInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitionsAtVersion_args)
getTablePartitionsAtVersion_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "timeTravelInfo",
        [guardrail.e6_metadata_common.ttypes.TableVersionInfo, None],
        None,
    ),  # 5
)


class getTablePartitionsAtVersion_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetTablePartitionsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitionsAtVersion_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitionsAtVersion_result)
getTablePartitionsAtVersion_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetTablePartitionsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getTablePartitionFileAndMetadataAtVersion_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - partitions
     - requestId
     - timeTravelInfo
     - shouldGetFileMetadata
     - columnsWithStats
     - getStatsForAllColumns

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        partitions=None,
        requestId=None,
        timeTravelInfo=None,
        shouldGetFileMetadata=None,
        columnsWithStats=None,
        getStatsForAllColumns=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.partitions = partitions
        self.requestId = requestId
        self.timeTravelInfo = timeTravelInfo
        self.shouldGetFileMetadata = shouldGetFileMetadata
        self.columnsWithStats = columnsWithStats
        self.getStatsForAllColumns = getStatsForAllColumns

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype232, _size229) = iprot.readListBegin()
                    for _i233 in range(_size229):
                        _elem234 = guardrail.e6_metadata_common.ttypes.E6PartitionInfo()
                        _elem234.read(iprot)
                        self.partitions.append(_elem234)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.timeTravelInfo = guardrail.e6_metadata_common.ttypes.TableVersionInfo()
                    self.timeTravelInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.shouldGetFileMetadata = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.columnsWithStats = []
                    (_etype238, _size235) = iprot.readListBegin()
                    for _i239 in range(_size235):
                        _elem240 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.columnsWithStats.append(_elem240)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.getStatsForAllColumns = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitionFileAndMetadataAtVersion_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin("partitions", TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter241 in self.partitions:
                iter241.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 5)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        if self.timeTravelInfo is not None:
            oprot.writeFieldBegin("timeTravelInfo", TType.STRUCT, 6)
            self.timeTravelInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.shouldGetFileMetadata is not None:
            oprot.writeFieldBegin("shouldGetFileMetadata", TType.BOOL, 7)
            oprot.writeBool(self.shouldGetFileMetadata)
            oprot.writeFieldEnd()
        if self.columnsWithStats is not None:
            oprot.writeFieldBegin("columnsWithStats", TType.LIST, 8)
            oprot.writeListBegin(TType.STRING, len(self.columnsWithStats))
            for iter242 in self.columnsWithStats:
                oprot.writeString(iter242.encode("utf-8") if sys.version_info[0] == 2 else iter242)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.getStatsForAllColumns is not None:
            oprot.writeFieldBegin("getStatsForAllColumns", TType.BOOL, 9)
            oprot.writeBool(self.getStatsForAllColumns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitionFileAndMetadataAtVersion_args)
getTablePartitionFileAndMetadataAtVersion_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "partitions",
        (TType.STRUCT, [guardrail.e6_metadata_common.ttypes.E6PartitionInfo, None], False),
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 5
    (
        6,
        TType.STRUCT,
        "timeTravelInfo",
        [guardrail.e6_metadata_common.ttypes.TableVersionInfo, None],
        None,
    ),  # 6
    (
        7,
        TType.BOOL,
        "shouldGetFileMetadata",
        None,
        None,
    ),  # 7
    (
        8,
        TType.LIST,
        "columnsWithStats",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 8
    (
        9,
        TType.BOOL,
        "getStatsForAllColumns",
        None,
        None,
    ),  # 9
)


class getTablePartitionFileAndMetadataAtVersion_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype246, _size243) = iprot.readListBegin()
                    for _i247 in range(_size243):
                        _elem248 = guardrail.e6_metadata_common.ttypes.PartitionPartFiles()
                        _elem248.read(iprot)
                        self.success.append(_elem248)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitionFileAndMetadataAtVersion_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter249 in self.success:
                iter249.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitionFileAndMetadataAtVersion_result)
getTablePartitionFileAndMetadataAtVersion_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [guardrail.e6_metadata_common.ttypes.PartitionPartFiles, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getTablePartitions_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - requestId
     - forceRefresh
     - lastUpdateTimeFromCache

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        requestId=None,
        forceRefresh=None,
        lastUpdateTimeFromCache=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.requestId = requestId
        self.forceRefresh = forceRefresh
        self.lastUpdateTimeFromCache = lastUpdateTimeFromCache

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.forceRefresh = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.lastUpdateTimeFromCache = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitions_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 4)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        if self.forceRefresh is not None:
            oprot.writeFieldBegin("forceRefresh", TType.BOOL, 5)
            oprot.writeBool(self.forceRefresh)
            oprot.writeFieldEnd()
        if self.lastUpdateTimeFromCache is not None:
            oprot.writeFieldBegin("lastUpdateTimeFromCache", TType.I64, 6)
            oprot.writeI64(self.lastUpdateTimeFromCache)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitions_args)
getTablePartitions_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.BOOL,
        "forceRefresh",
        None,
        None,
    ),  # 5
    (
        6,
        TType.I64,
        "lastUpdateTimeFromCache",
        None,
        None,
    ),  # 6
)


class getTablePartitions_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetTablePartitionsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitions_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitions_result)
getTablePartitions_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [GetTablePartitionsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getTablePartitionFileAndMetadata_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - partitions
     - requestId
     - forcerefresh
     - shouldGetFileMetadata
     - columnsWithStats
     - getStatsForAllColumns

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        partitions=None,
        requestId=None,
        forcerefresh=None,
        shouldGetFileMetadata=None,
        columnsWithStats=None,
        getStatsForAllColumns=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.partitions = partitions
        self.requestId = requestId
        self.forcerefresh = forcerefresh
        self.shouldGetFileMetadata = shouldGetFileMetadata
        self.columnsWithStats = columnsWithStats
        self.getStatsForAllColumns = getStatsForAllColumns

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype253, _size250) = iprot.readListBegin()
                    for _i254 in range(_size250):
                        _elem255 = guardrail.e6_metadata_common.ttypes.E6PartitionInfo()
                        _elem255.read(iprot)
                        self.partitions.append(_elem255)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.forcerefresh = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.shouldGetFileMetadata = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.columnsWithStats = []
                    (_etype259, _size256) = iprot.readListBegin()
                    for _i260 in range(_size256):
                        _elem261 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.columnsWithStats.append(_elem261)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.getStatsForAllColumns = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitionFileAndMetadata_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin("partitions", TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter262 in self.partitions:
                iter262.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 5)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        if self.forcerefresh is not None:
            oprot.writeFieldBegin("forcerefresh", TType.BOOL, 6)
            oprot.writeBool(self.forcerefresh)
            oprot.writeFieldEnd()
        if self.shouldGetFileMetadata is not None:
            oprot.writeFieldBegin("shouldGetFileMetadata", TType.BOOL, 7)
            oprot.writeBool(self.shouldGetFileMetadata)
            oprot.writeFieldEnd()
        if self.columnsWithStats is not None:
            oprot.writeFieldBegin("columnsWithStats", TType.LIST, 8)
            oprot.writeListBegin(TType.STRING, len(self.columnsWithStats))
            for iter263 in self.columnsWithStats:
                oprot.writeString(iter263.encode("utf-8") if sys.version_info[0] == 2 else iter263)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.getStatsForAllColumns is not None:
            oprot.writeFieldBegin("getStatsForAllColumns", TType.BOOL, 9)
            oprot.writeBool(self.getStatsForAllColumns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitionFileAndMetadata_args)
getTablePartitionFileAndMetadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "partitions",
        (TType.STRUCT, [guardrail.e6_metadata_common.ttypes.E6PartitionInfo, None], False),
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 5
    (
        6,
        TType.BOOL,
        "forcerefresh",
        None,
        None,
    ),  # 6
    (
        7,
        TType.BOOL,
        "shouldGetFileMetadata",
        None,
        None,
    ),  # 7
    (
        8,
        TType.LIST,
        "columnsWithStats",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 8
    (
        9,
        TType.BOOL,
        "getStatsForAllColumns",
        None,
        None,
    ),  # 9
)


class getTablePartitionFileAndMetadata_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype267, _size264) = iprot.readListBegin()
                    for _i268 in range(_size264):
                        _elem269 = guardrail.e6_metadata_common.ttypes.PartitionPartFiles()
                        _elem269.read(iprot)
                        self.success.append(_elem269)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitionFileAndMetadata_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter270 in self.success:
                iter270.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitionFileAndMetadata_result)
getTablePartitionFileAndMetadata_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [guardrail.e6_metadata_common.ttypes.PartitionPartFiles, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class putFileMetadata_args(object):
    """
    Attributes:
     - partFiles
     - requestId

    """

    thrift_spec = None

    def __init__(
        self,
        partFiles=None,
        requestId=None,
    ):
        self.partFiles = partFiles
        self.requestId = requestId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partFiles = []
                    (_etype274, _size271) = iprot.readListBegin()
                    for _i275 in range(_size271):
                        _elem276 = guardrail.e6_metadata_common.ttypes.PartFile()
                        _elem276.read(iprot)
                        self.partFiles.append(_elem276)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("putFileMetadata_args")
        if self.partFiles is not None:
            oprot.writeFieldBegin("partFiles", TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partFiles))
            for iter277 in self.partFiles:
                iter277.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 2)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(putFileMetadata_args)
putFileMetadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "partFiles",
        (TType.STRUCT, [guardrail.e6_metadata_common.ttypes.PartFile, None], False),
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 2
)


class bulkAddCatalogs_args(object):
    """
    Attributes:
     - catalogsJson

    """

    thrift_spec = None

    def __init__(
        self,
        catalogsJson=None,
    ):
        self.catalogsJson = catalogsJson

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogsJson = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("bulkAddCatalogs_args")
        if self.catalogsJson is not None:
            oprot.writeFieldBegin("catalogsJson", TType.STRING, 1)
            oprot.writeString(
                self.catalogsJson.encode("utf-8") if sys.version_info[0] == 2 else self.catalogsJson
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(bulkAddCatalogs_args)
bulkAddCatalogs_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogsJson",
        "UTF8",
        None,
    ),  # 1
)


class bulkAddCatalogs_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = BulkAddCatalogsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("bulkAddCatalogs_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(bulkAddCatalogs_result)
bulkAddCatalogs_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [BulkAddCatalogsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class refreshCatalog_args(object):
    """
    Attributes:
     - catalogName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
    ):
        self.catalogName = catalogName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("refreshCatalog_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(refreshCatalog_args)
refreshCatalog_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
)


class refreshCatalog_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StorageServiceRef()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("refreshCatalog_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(refreshCatalog_result)
refreshCatalog_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [StorageServiceRef, None],
        None,
    ),  # 0
)


class getAddOrRefreshCatalogResponse_args(object):
    """
    Attributes:
     - catalogName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
    ):
        self.catalogName = catalogName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getAddOrRefreshCatalogResponse_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getAddOrRefreshCatalogResponse_args)
getAddOrRefreshCatalogResponse_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
)


class getAddOrRefreshCatalogResponse_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AddOrRefreshCatalogResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getAddOrRefreshCatalogResponse_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getAddOrRefreshCatalogResponse_result)
getAddOrRefreshCatalogResponse_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [AddOrRefreshCatalogResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class forceBulkAddCatalogs_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("forceBulkAddCatalogs_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(forceBulkAddCatalogs_args)
forceBulkAddCatalogs_args.thrift_spec = ()


class forceBulkAddCatalogs_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = BulkAddCatalogsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("forceBulkAddCatalogs_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(forceBulkAddCatalogs_result)
forceBulkAddCatalogs_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [BulkAddCatalogsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class refreshDBs_args(object):
    """
    Attributes:
     - catalogName
     - dbName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dbName = []
                    (_etype281, _size278) = iprot.readListBegin()
                    for _i282 in range(_size278):
                        _elem283 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.dbName.append(_elem283)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("refreshDBs_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.dbName))
            for iter284 in self.dbName:
                oprot.writeString(iter284.encode("utf-8") if sys.version_info[0] == 2 else iter284)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(refreshDBs_args)
refreshDBs_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "dbName",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 2
)


class refreshDBs_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StorageServiceRef()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("refreshDBs_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(refreshDBs_result)
refreshDBs_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [StorageServiceRef, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getRefreshDBsResponse_args(object):
    """
    Attributes:
     - catalogName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
    ):
        self.catalogName = catalogName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getRefreshDBsResponse_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getRefreshDBsResponse_args)
getRefreshDBsResponse_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
)


class getRefreshDBsResponse_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RefreshDBsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getRefreshDBsResponse_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getRefreshDBsResponse_result)
getRefreshDBsResponse_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [RefreshDBsResponse, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class dropCatalog_args(object):
    """
    Attributes:
     - catalogName

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
    ):
        self.catalogName = catalogName

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("dropCatalog_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(dropCatalog_args)
dropCatalog_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
)


class dropCatalog_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("dropCatalog_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(dropCatalog_result)
dropCatalog_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class dBNamesCallback_args(object):
    """
    Attributes:
     - dbNames
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        dbNames=None,
        requestContext=None,
    ):
        self.dbNames = dbNames
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dbNames = []
                    (_etype288, _size285) = iprot.readListBegin()
                    for _i289 in range(_size285):
                        _elem290 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.dbNames.append(_elem290)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = guardrail.e6_schema_service.ttypes.RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("dBNamesCallback_args")
        if self.dbNames is not None:
            oprot.writeFieldBegin("dbNames", TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.dbNames))
            for iter291 in self.dbNames:
                oprot.writeString(iter291.encode("utf-8") if sys.version_info[0] == 2 else iter291)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(dBNamesCallback_args)
dBNamesCallback_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "dbNames",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [guardrail.e6_schema_service.ttypes.RequestContext, None],
        None,
    ),  # 2
)


class dBNamesCallback_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("dBNamesCallback_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(dBNamesCallback_result)
dBNamesCallback_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class tableNamesCallback_args(object):
    """
    Attributes:
     - tableNames
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        tableNames=None,
        requestContext=None,
    ):
        self.tableNames = tableNames
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tableNames = []
                    (_etype295, _size292) = iprot.readListBegin()
                    for _i296 in range(_size292):
                        _elem297 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.tableNames.append(_elem297)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = guardrail.e6_schema_service.ttypes.RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tableNamesCallback_args")
        if self.tableNames is not None:
            oprot.writeFieldBegin("tableNames", TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.tableNames))
            for iter298 in self.tableNames:
                oprot.writeString(iter298.encode("utf-8") if sys.version_info[0] == 2 else iter298)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tableNamesCallback_args)
tableNamesCallback_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "tableNames",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [guardrail.e6_schema_service.ttypes.RequestContext, None],
        None,
    ),  # 2
)


class tableNamesCallback_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tableNamesCallback_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tableNamesCallback_result)
tableNamesCallback_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class tablesCallback_args(object):
    """
    Attributes:
     - listTablesCallback
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        listTablesCallback=None,
        requestContext=None,
    ):
        self.listTablesCallback = listTablesCallback
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.listTablesCallback = []
                    (_etype302, _size299) = iprot.readListBegin()
                    for _i303 in range(_size299):
                        _elem304 = TableCallbackInfo()
                        _elem304.read(iprot)
                        self.listTablesCallback.append(_elem304)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = guardrail.e6_schema_service.ttypes.RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tablesCallback_args")
        if self.listTablesCallback is not None:
            oprot.writeFieldBegin("listTablesCallback", TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.listTablesCallback))
            for iter305 in self.listTablesCallback:
                iter305.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tablesCallback_args)
tablesCallback_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "listTablesCallback",
        (TType.STRUCT, [TableCallbackInfo, None], False),
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [guardrail.e6_schema_service.ttypes.RequestContext, None],
        None,
    ),  # 2
)


class tablesCallback_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tablesCallback_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tablesCallback_result)
tablesCallback_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class tableStatisticsCallback_args(object):
    """
    Attributes:
     - tableStats
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        tableStats=None,
        requestContext=None,
    ):
        self.tableStats = tableStats
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableStats = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = guardrail.e6_schema_service.ttypes.RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tableStatisticsCallback_args")
        if self.tableStats is not None:
            oprot.writeFieldBegin("tableStats", TType.STRING, 1)
            oprot.writeBinary(self.tableStats)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tableStatisticsCallback_args)
tableStatisticsCallback_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "tableStats",
        "BINARY",
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [guardrail.e6_schema_service.ttypes.RequestContext, None],
        None,
    ),  # 2
)


class tableStatisticsCallback_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tableStatisticsCallback_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tableStatisticsCallback_result)
tableStatisticsCallback_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class tablePartitionsCallback_args(object):
    """
    Attributes:
     - partitions
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        partitions=None,
        requestContext=None,
    ):
        self.partitions = partitions
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype309, _size306) = iprot.readListBegin()
                    for _i310 in range(_size306):
                        _elem311 = guardrail.e6_metadata_common.ttypes.E6Partition()
                        _elem311.read(iprot)
                        self.partitions.append(_elem311)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = guardrail.e6_schema_service.ttypes.RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tablePartitionsCallback_args")
        if self.partitions is not None:
            oprot.writeFieldBegin("partitions", TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter312 in self.partitions:
                iter312.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tablePartitionsCallback_args)
tablePartitionsCallback_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "partitions",
        (TType.STRUCT, [guardrail.e6_metadata_common.ttypes.E6Partition, None], False),
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [guardrail.e6_schema_service.ttypes.RequestContext, None],
        None,
    ),  # 2
)


class tablePartitionsCallback_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tablePartitionsCallback_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tablePartitionsCallback_result)
tablePartitionsCallback_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class deltaTablePartitionsCallback_args(object):
    """
    Attributes:
     - deltaTableChangeResponse
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        deltaTableChangeResponse=None,
        requestContext=None,
    ):
        self.deltaTableChangeResponse = deltaTableChangeResponse
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deltaTableChangeResponse = DeltaTableChangeResponse()
                    self.deltaTableChangeResponse.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = guardrail.e6_schema_service.ttypes.RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("deltaTablePartitionsCallback_args")
        if self.deltaTableChangeResponse is not None:
            oprot.writeFieldBegin("deltaTableChangeResponse", TType.STRUCT, 1)
            self.deltaTableChangeResponse.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(deltaTablePartitionsCallback_args)
deltaTablePartitionsCallback_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "deltaTableChangeResponse",
        [DeltaTableChangeResponse, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [guardrail.e6_schema_service.ttypes.RequestContext, None],
        None,
    ),  # 2
)


class deltaTablePartitionsCallback_result(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("deltaTablePartitionsCallback_result")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(deltaTablePartitionsCallback_result)
deltaTablePartitionsCallback_result.thrift_spec = ()


class tablePartitionFilesCallback_args(object):
    """
    Attributes:
     - mapPartitionNameAndFileMetadatas
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        mapPartitionNameAndFileMetadatas=None,
        requestContext=None,
    ):
        self.mapPartitionNameAndFileMetadatas = mapPartitionNameAndFileMetadatas
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.mapPartitionNameAndFileMetadatas = {}
                    (_ktype314, _vtype315, _size313) = iprot.readMapBegin()
                    for _i317 in range(_size313):
                        _key318 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val319 = []
                        (_etype323, _size320) = iprot.readListBegin()
                        for _i324 in range(_size320):
                            _elem325 = guardrail.e6_schema_service.ttypes.FileStatus()
                            _elem325.read(iprot)
                            _val319.append(_elem325)
                        iprot.readListEnd()
                        self.mapPartitionNameAndFileMetadatas[_key318] = _val319
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = guardrail.e6_schema_service.ttypes.RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tablePartitionFilesCallback_args")
        if self.mapPartitionNameAndFileMetadatas is not None:
            oprot.writeFieldBegin("mapPartitionNameAndFileMetadatas", TType.MAP, 1)
            oprot.writeMapBegin(
                TType.STRING, TType.LIST, len(self.mapPartitionNameAndFileMetadatas)
            )
            for kiter326, viter327 in self.mapPartitionNameAndFileMetadatas.items():
                oprot.writeString(
                    kiter326.encode("utf-8") if sys.version_info[0] == 2 else kiter326
                )
                oprot.writeListBegin(TType.STRUCT, len(viter327))
                for iter328 in viter327:
                    iter328.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tablePartitionFilesCallback_args)
tablePartitionFilesCallback_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.MAP,
        "mapPartitionNameAndFileMetadatas",
        (
            TType.STRING,
            "UTF8",
            TType.LIST,
            (TType.STRUCT, [guardrail.e6_schema_service.ttypes.FileStatus, None], False),
            False,
        ),
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [guardrail.e6_schema_service.ttypes.RequestContext, None],
        None,
    ),  # 2
)


class tablePartitionFilesCallback_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tablePartitionFilesCallback_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tablePartitionFilesCallback_result)
tablePartitionFilesCallback_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class tableFileMetadataCallback_args(object):
    """
    Attributes:
     - listFileMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        listFileMetadata=None,
        requestContext=None,
    ):
        self.listFileMetadata = listFileMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.listFileMetadata = []
                    (_etype332, _size329) = iprot.readListBegin()
                    for _i333 in range(_size329):
                        _elem334 = guardrail.e6_metadata_common.ttypes.PartFile()
                        _elem334.read(iprot)
                        self.listFileMetadata.append(_elem334)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = guardrail.e6_schema_service.ttypes.RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tableFileMetadataCallback_args")
        if self.listFileMetadata is not None:
            oprot.writeFieldBegin("listFileMetadata", TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.listFileMetadata))
            for iter335 in self.listFileMetadata:
                iter335.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tableFileMetadataCallback_args)
tableFileMetadataCallback_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "listFileMetadata",
        (TType.STRUCT, [guardrail.e6_metadata_common.ttypes.PartFile, None], False),
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [guardrail.e6_schema_service.ttypes.RequestContext, None],
        None,
    ),  # 2
)


class tableFileMetadataCallback_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("tableFileMetadataCallback_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(tableFileMetadataCallback_result)
tableFileMetadataCallback_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getAdditionalDataCallback_args(object):
    """
    Attributes:
     - mapPartitiontoDeletionVectors
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        mapPartitiontoDeletionVectors=None,
        requestContext=None,
    ):
        self.mapPartitiontoDeletionVectors = mapPartitiontoDeletionVectors
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.mapPartitiontoDeletionVectors = {}
                    (_ktype337, _vtype338, _size336) = iprot.readMapBegin()
                    for _i340 in range(_size336):
                        _key341 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val342 = {}
                        (_ktype344, _vtype345, _size343) = iprot.readMapBegin()
                        for _i347 in range(_size343):
                            _key348 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val349 = guardrail.e6_metadata_common.ttypes.DeletionVector()
                            _val349.read(iprot)
                            _val342[_key348] = _val349
                        iprot.readMapEnd()
                        self.mapPartitiontoDeletionVectors[_key341] = _val342
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = guardrail.e6_schema_service.ttypes.RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getAdditionalDataCallback_args")
        if self.mapPartitiontoDeletionVectors is not None:
            oprot.writeFieldBegin("mapPartitiontoDeletionVectors", TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.mapPartitiontoDeletionVectors))
            for kiter350, viter351 in self.mapPartitiontoDeletionVectors.items():
                oprot.writeString(
                    kiter350.encode("utf-8") if sys.version_info[0] == 2 else kiter350
                )
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter351))
                for kiter352, viter353 in viter351.items():
                    oprot.writeString(
                        kiter352.encode("utf-8") if sys.version_info[0] == 2 else kiter352
                    )
                    viter353.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getAdditionalDataCallback_args)
getAdditionalDataCallback_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.MAP,
        "mapPartitiontoDeletionVectors",
        (
            TType.STRING,
            "UTF8",
            TType.MAP,
            (
                TType.STRING,
                "UTF8",
                TType.STRUCT,
                [guardrail.e6_metadata_common.ttypes.DeletionVector, None],
                False,
            ),
            False,
        ),
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [guardrail.e6_schema_service.ttypes.RequestContext, None],
        None,
    ),  # 2
)


class getAdditionalDataCallback_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getAdditionalDataCallback_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getAdditionalDataCallback_result)
getAdditionalDataCallback_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class upsertDBNames_args(object):
    """
    Attributes:
     - catalogName
     - dbNames

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbNames=None,
    ):
        self.catalogName = catalogName
        self.dbNames = dbNames

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dbNames = []
                    (_etype357, _size354) = iprot.readListBegin()
                    for _i358 in range(_size354):
                        _elem359 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.dbNames.append(_elem359)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertDBNames_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbNames is not None:
            oprot.writeFieldBegin("dbNames", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.dbNames))
            for iter360 in self.dbNames:
                oprot.writeString(iter360.encode("utf-8") if sys.version_info[0] == 2 else iter360)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertDBNames_args)
upsertDBNames_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "dbNames",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 2
)


class upsertDBNames_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertDBNames_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertDBNames_result)
upsertDBNames_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class upsertTableNames_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableNames

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableNames=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableNames = tableNames

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tableNames = []
                    (_etype364, _size361) = iprot.readListBegin()
                    for _i365 in range(_size361):
                        _elem366 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.tableNames.append(_elem366)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTableNames_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableNames is not None:
            oprot.writeFieldBegin("tableNames", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.tableNames))
            for iter367 in self.tableNames:
                oprot.writeString(iter367.encode("utf-8") if sys.version_info[0] == 2 else iter367)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTableNames_args)
upsertTableNames_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "tableNames",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
)


class upsertTableNames_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTableNames_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTableNames_result)
upsertTableNames_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class upsertTables_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tables

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tables=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tables = tables

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tables = []
                    (_etype371, _size368) = iprot.readListBegin()
                    for _i372 in range(_size368):
                        _elem373 = iprot.readBinary()
                        self.tables.append(_elem373)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTables_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tables is not None:
            oprot.writeFieldBegin("tables", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.tables))
            for iter374 in self.tables:
                oprot.writeBinary(iter374)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTables_args)
upsertTables_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "tables",
        (TType.STRING, "BINARY", False),
        None,
    ),  # 3
)


class upsertTables_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTables_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTables_result)
upsertTables_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class upsertTableStatistics_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - tableStats

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        tableStats=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.tableStats = tableStats

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tableStats = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTableStatistics_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.tableStats is not None:
            oprot.writeFieldBegin("tableStats", TType.STRING, 4)
            oprot.writeBinary(self.tableStats)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTableStatistics_args)
upsertTableStatistics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "tableStats",
        "BINARY",
        None,
    ),  # 4
)


class upsertTableStatistics_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTableStatistics_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTableStatistics_result)
upsertTableStatistics_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class upsertTablePartitions_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - partitions

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        partitions=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.partitions = partitions

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype378, _size375) = iprot.readListBegin()
                    for _i379 in range(_size375):
                        _elem380 = iprot.readBinary()
                        self.partitions.append(_elem380)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTablePartitions_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin("partitions", TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.partitions))
            for iter381 in self.partitions:
                oprot.writeBinary(iter381)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTablePartitions_args)
upsertTablePartitions_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "partitions",
        (TType.STRING, "BINARY", False),
        None,
    ),  # 4
)


class upsertTablePartitions_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTablePartitions_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTablePartitions_result)
upsertTablePartitions_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class upsertTablePartitionFiles_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - mapPartitionNameAndFileMetadata

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        mapPartitionNameAndFileMetadata=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.mapPartitionNameAndFileMetadata = mapPartitionNameAndFileMetadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.mapPartitionNameAndFileMetadata = {}
                    (_ktype383, _vtype384, _size382) = iprot.readMapBegin()
                    for _i386 in range(_size382):
                        _key387 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val388 = []
                        (_etype392, _size389) = iprot.readListBegin()
                        for _i393 in range(_size389):
                            _elem394 = guardrail.e6_schema_service.ttypes.FileStatus()
                            _elem394.read(iprot)
                            _val388.append(_elem394)
                        iprot.readListEnd()
                        self.mapPartitionNameAndFileMetadata[_key387] = _val388
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTablePartitionFiles_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.mapPartitionNameAndFileMetadata is not None:
            oprot.writeFieldBegin("mapPartitionNameAndFileMetadata", TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.mapPartitionNameAndFileMetadata))
            for kiter395, viter396 in self.mapPartitionNameAndFileMetadata.items():
                oprot.writeString(
                    kiter395.encode("utf-8") if sys.version_info[0] == 2 else kiter395
                )
                oprot.writeListBegin(TType.STRUCT, len(viter396))
                for iter397 in viter396:
                    iter397.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTablePartitionFiles_args)
upsertTablePartitionFiles_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.MAP,
        "mapPartitionNameAndFileMetadata",
        (
            TType.STRING,
            "UTF8",
            TType.LIST,
            (TType.STRUCT, [guardrail.e6_schema_service.ttypes.FileStatus, None], False),
            False,
        ),
        None,
    ),  # 4
)


class upsertTablePartitionFiles_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTablePartitionFiles_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTablePartitionFiles_result)
upsertTablePartitionFiles_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class upsertTableFileMetadata_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - fileMetadata

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        fileMetadata=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.fileMetadata = fileMetadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.fileMetadata = guardrail.e6_metadata_common.ttypes.PartFile()
                    self.fileMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTableFileMetadata_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.fileMetadata is not None:
            oprot.writeFieldBegin("fileMetadata", TType.STRUCT, 4)
            self.fileMetadata.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTableFileMetadata_args)
upsertTableFileMetadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "fileMetadata",
        [guardrail.e6_metadata_common.ttypes.PartFile, None],
        None,
    ),  # 4
)


class upsertTableFileMetadata_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("upsertTableFileMetadata_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(upsertTableFileMetadata_result)
upsertTableFileMetadata_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class getCatalogDump_args(object):
    """
    Attributes:
     - catalogDumpRequest

    """

    thrift_spec = None

    def __init__(
        self,
        catalogDumpRequest=None,
    ):
        self.catalogDumpRequest = catalogDumpRequest

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catalogDumpRequest = CatalogDumpRequest()
                    self.catalogDumpRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getCatalogDump_args")
        if self.catalogDumpRequest is not None:
            oprot.writeFieldBegin("catalogDumpRequest", TType.STRUCT, 1)
            self.catalogDumpRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getCatalogDump_args)
getCatalogDump_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "catalogDumpRequest",
        [CatalogDumpRequest, None],
        None,
    ),  # 1
)


class getCatalogDump_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype401, _size398) = iprot.readListBegin()
                    for _i402 in range(_size398):
                        _elem403 = Dump()
                        _elem403.read(iprot)
                        self.success.append(_elem403)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getCatalogDump_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter404 in self.success:
                iter404.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getCatalogDump_result)
getCatalogDump_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Dump, None], False),
        None,
    ),  # 0
)


class analyzeTable_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - columnNames
     - requestId

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        columnNames=None,
        requestId=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.columnNames = columnNames
        self.requestId = requestId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.columnNames = []
                    (_etype408, _size405) = iprot.readListBegin()
                    for _i409 in range(_size405):
                        _elem410 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.columnNames.append(_elem410)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("analyzeTable_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.columnNames is not None:
            oprot.writeFieldBegin("columnNames", TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.columnNames))
            for iter411 in self.columnNames:
                oprot.writeString(iter411.encode("utf-8") if sys.version_info[0] == 2 else iter411)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 5)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(analyzeTable_args)
analyzeTable_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "columnNames",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 5
)


class analyzeTable_result(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("analyzeTable_result")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(analyzeTable_result)
analyzeTable_result.thrift_spec = ()


class getAnalyzedTableInfo_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - requestId

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        requestId=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.requestId = requestId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getAnalyzedTableInfo_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 5)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getAnalyzedTableInfo_args)
getAnalyzedTableInfo_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    None,  # 4
    (
        5,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 5
)


class getAnalyzedTableInfo_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AnalyzedTableInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getAnalyzedTableInfo_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getAnalyzedTableInfo_result)
getAnalyzedTableInfo_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [AnalyzedTableInfo, None],
        None,
    ),  # 0
)


class getHistoricalStats_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getHistoricalStats_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getHistoricalStats_args)
getHistoricalStats_args.thrift_spec = ()


class getHistoricalStats_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype413, _vtype414, _size412) = iprot.readMapBegin()
                    for _i416 in range(_size412):
                        _key417 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val418 = HBOStats()
                        _val418.read(iprot)
                        self.success[_key417] = _val418
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getHistoricalStats_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter419, viter420 in self.success.items():
                oprot.writeString(
                    kiter419.encode("utf-8") if sys.version_info[0] == 2 else kiter419
                )
                viter420.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getHistoricalStats_result)
getHistoricalStats_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRUCT, [HBOStats, None], False),
        None,
    ),  # 0
)


class updateHBOCacheInStorage_args(object):
    """
    Attributes:
     - stats

    """

    thrift_spec = None

    def __init__(
        self,
        stats=None,
    ):
        self.stats = stats

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.stats = {}
                    (_ktype422, _vtype423, _size421) = iprot.readMapBegin()
                    for _i425 in range(_size421):
                        _key426 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val427 = HBOStats()
                        _val427.read(iprot)
                        self.stats[_key426] = _val427
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("updateHBOCacheInStorage_args")
        if self.stats is not None:
            oprot.writeFieldBegin("stats", TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.stats))
            for kiter428, viter429 in self.stats.items():
                oprot.writeString(
                    kiter428.encode("utf-8") if sys.version_info[0] == 2 else kiter428
                )
                viter429.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(updateHBOCacheInStorage_args)
updateHBOCacheInStorage_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.MAP,
        "stats",
        (TType.STRING, "UTF8", TType.STRUCT, [HBOStats, None], False),
        None,
    ),  # 1
)


class createView_args(object):
    """
    Attributes:
     - catalogName
     - databaseName
     - tableName
     - requestId
     - table

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        databaseName=None,
        tableName=None,
        requestId=None,
        table=None,
    ):
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.tableName = tableName
        self.requestId = requestId
        self.table = table

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.databaseName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.table = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("createView_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.databaseName is not None:
            oprot.writeFieldBegin("databaseName", TType.STRING, 2)
            oprot.writeString(
                self.databaseName.encode("utf-8") if sys.version_info[0] == 2 else self.databaseName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 4)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin("table", TType.STRING, 5)
            oprot.writeBinary(self.table)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(createView_args)
createView_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "databaseName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "table",
        "BINARY",
        None,
    ),  # 5
)


class createView_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("createView_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(createView_result)
createView_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class updateView_args(object):
    """
    Attributes:
     - catalogName
     - databaseName
     - tableName
     - table
     - requestId

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        databaseName=None,
        tableName=None,
        table=None,
        requestId=None,
    ):
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.tableName = tableName
        self.table = table
        self.requestId = requestId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.databaseName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.table = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("updateView_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.databaseName is not None:
            oprot.writeFieldBegin("databaseName", TType.STRING, 2)
            oprot.writeString(
                self.databaseName.encode("utf-8") if sys.version_info[0] == 2 else self.databaseName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin("table", TType.STRING, 4)
            oprot.writeBinary(self.table)
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 5)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(updateView_args)
updateView_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "databaseName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "table",
        "BINARY",
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 5
)


class updateView_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("updateView_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(updateView_result)
updateView_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class alterView_args(object):
    """
    Attributes:
     - catalogName
     - databaseName
     - tableName
     - requestId
     - table

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        databaseName=None,
        tableName=None,
        requestId=None,
        table=None,
    ):
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.tableName = tableName
        self.requestId = requestId
        self.table = table

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.databaseName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.table = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alterView_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.databaseName is not None:
            oprot.writeFieldBegin("databaseName", TType.STRING, 2)
            oprot.writeString(
                self.databaseName.encode("utf-8") if sys.version_info[0] == 2 else self.databaseName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 4)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin("table", TType.STRING, 5)
            oprot.writeBinary(self.table)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alterView_args)
alterView_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "databaseName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "table",
        "BINARY",
        None,
    ),  # 5
)


class alterView_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("alterView_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(alterView_result)
alterView_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)


class dropView_args(object):
    """
    Attributes:
     - catalogName
     - databaseName
     - tableName
     - requestId

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        databaseName=None,
        tableName=None,
        requestId=None,
    ):
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.tableName = tableName
        self.requestId = requestId

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.databaseName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.requestId = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("dropView_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.databaseName is not None:
            oprot.writeFieldBegin("databaseName", TType.STRING, 2)
            oprot.writeString(
                self.databaseName.encode("utf-8") if sys.version_info[0] == 2 else self.databaseName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestId is not None:
            oprot.writeFieldBegin("requestId", TType.STRING, 4)
            oprot.writeString(
                self.requestId.encode("utf-8") if sys.version_info[0] == 2 else self.requestId
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(dropView_args)
dropView_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "databaseName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "requestId",
        "UTF8",
        None,
    ),  # 4
)


class dropView_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = StorageServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("dropView_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(dropView_result)
dropView_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [StorageServiceException, None],
        None,
    ),  # 1
)
fix_spec(all_structs)
del all_structs
