#
# Autogenerated by Thrift Compiler (0.21.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import e6_schema_service.ttypes
import e6_metadata_common.ttypes

from thrift.transport import TTransport

all_structs = []


class StorageServiceException(TException):
    """
    Attributes:
     - reason

    """

    thrift_spec = None

    def __init__(
        self,
        reason=None,
    ):
        super(StorageServiceException, self).__setattr__("reason", reason)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.reason,))

    @classmethod
    def read(cls, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and cls.thrift_spec is not None
        ):
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        reason = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    reason = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            reason=reason,
        )

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("StorageServiceException")
        if self.reason is not None:
            oprot.writeFieldBegin("reason", TType.STRING, 1)
            oprot.writeString(
                self.reason.encode("utf-8") if sys.version_info[0] == 2 else self.reason
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FailedSchemaElement(object):
    """
    Attributes:
     - name
     - type
     - reason

    """

    thrift_spec = None

    def __init__(
        self,
        name=None,
        type=None,
        reason=None,
    ):
        self.name = name
        self.type = type
        self.reason = reason

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.reason = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("FailedSchemaElement")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin("type", TType.STRING, 2)
            oprot.writeString(self.type.encode("utf-8") if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.reason is not None:
            oprot.writeFieldBegin("reason", TType.STRING, 3)
            oprot.writeString(
                self.reason.encode("utf-8") if sys.version_info[0] == 2 else self.reason
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AddOrRefreshCatalogResponse(object):
    """
    Attributes:
     - status
     - failures
     - diagnosticsFilePath

    """

    thrift_spec = None

    def __init__(
        self,
        status=None,
        failures=None,
        diagnosticsFilePath=None,
    ):
        self.status = status
        self.failures = failures
        self.diagnosticsFilePath = diagnosticsFilePath

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.status = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.failures = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = FailedSchemaElement()
                        _elem5.read(iprot)
                        self.failures.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.diagnosticsFilePath = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("AddOrRefreshCatalogResponse")
        if self.status is not None:
            oprot.writeFieldBegin("status", TType.STRING, 1)
            oprot.writeString(
                self.status.encode("utf-8") if sys.version_info[0] == 2 else self.status
            )
            oprot.writeFieldEnd()
        if self.failures is not None:
            oprot.writeFieldBegin("failures", TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.failures))
            for iter6 in self.failures:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.diagnosticsFilePath is not None:
            oprot.writeFieldBegin("diagnosticsFilePath", TType.STRING, 3)
            oprot.writeString(
                self.diagnosticsFilePath.encode("utf-8")
                if sys.version_info[0] == 2
                else self.diagnosticsFilePath
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StorageServiceRef(object):
    """
    Attributes:
     - hostName
     - port

    """

    thrift_spec = None

    def __init__(
        self,
        hostName=None,
        port=None,
    ):
        self.hostName = hostName
        self.port = port

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hostName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("StorageServiceRef")
        if self.hostName is not None:
            oprot.writeFieldBegin("hostName", TType.STRING, 1)
            oprot.writeString(
                self.hostName.encode("utf-8") if sys.version_info[0] == 2 else self.hostName
            )
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin("port", TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BulkAddCatalogsResponse(object):
    """
    Attributes:
     - storageServiceRef
     - catalogsAdditionStarted
     - failures

    """

    thrift_spec = None

    def __init__(
        self,
        storageServiceRef=None,
        catalogsAdditionStarted=None,
        failures=None,
    ):
        self.storageServiceRef = storageServiceRef
        self.catalogsAdditionStarted = catalogsAdditionStarted
        self.failures = failures

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.storageServiceRef = StorageServiceRef()
                    self.storageServiceRef.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.catalogsAdditionStarted = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.catalogsAdditionStarted.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.failures = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = FailedSchemaElement()
                        _elem18.read(iprot)
                        self.failures.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("BulkAddCatalogsResponse")
        if self.storageServiceRef is not None:
            oprot.writeFieldBegin("storageServiceRef", TType.STRUCT, 1)
            self.storageServiceRef.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogsAdditionStarted is not None:
            oprot.writeFieldBegin("catalogsAdditionStarted", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.catalogsAdditionStarted))
            for iter19 in self.catalogsAdditionStarted:
                oprot.writeString(iter19.encode("utf-8") if sys.version_info[0] == 2 else iter19)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.failures is not None:
            oprot.writeFieldBegin("failures", TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.failures))
            for iter20 in self.failures:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RefreshDBsResponse(object):
    """
    Attributes:
     - status
     - failures
     - diagnosticsFilePath

    """

    thrift_spec = None

    def __init__(
        self,
        status=None,
        failures=None,
        diagnosticsFilePath=None,
    ):
        self.status = status
        self.failures = failures
        self.diagnosticsFilePath = diagnosticsFilePath

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.status = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.failures = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = FailedSchemaElement()
                        _elem26.read(iprot)
                        self.failures.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.diagnosticsFilePath = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("RefreshDBsResponse")
        if self.status is not None:
            oprot.writeFieldBegin("status", TType.STRING, 1)
            oprot.writeString(
                self.status.encode("utf-8") if sys.version_info[0] == 2 else self.status
            )
            oprot.writeFieldEnd()
        if self.failures is not None:
            oprot.writeFieldBegin("failures", TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.failures))
            for iter27 in self.failures:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.diagnosticsFilePath is not None:
            oprot.writeFieldBegin("diagnosticsFilePath", TType.STRING, 3)
            oprot.writeString(
                self.diagnosticsFilePath.encode("utf-8")
                if sys.version_info[0] == 2
                else self.diagnosticsFilePath
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FieldMetadata(object):
    """
    Attributes:
     - fieldName
     - fieldType
     - childFields

    """

    thrift_spec = None

    def __init__(
        self,
        fieldName=None,
        fieldType=None,
        childFields=None,
    ):
        self.fieldName = fieldName
        self.fieldType = fieldType
        self.childFields = childFields

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fieldName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.fieldType = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.childFields = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = FieldMetadata()
                        _elem33.read(iprot)
                        self.childFields.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("FieldMetadata")
        if self.fieldName is not None:
            oprot.writeFieldBegin("fieldName", TType.STRING, 1)
            oprot.writeString(
                self.fieldName.encode("utf-8") if sys.version_info[0] == 2 else self.fieldName
            )
            oprot.writeFieldEnd()
        if self.fieldType is not None:
            oprot.writeFieldBegin("fieldType", TType.STRING, 2)
            oprot.writeString(
                self.fieldType.encode("utf-8") if sys.version_info[0] == 2 else self.fieldType
            )
            oprot.writeFieldEnd()
        if self.childFields is not None:
            oprot.writeFieldBegin("childFields", TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.childFields))
            for iter34 in self.childFields:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CatalogMetadata(object):
    """
    Attributes:
     - catalogName
     - schemaName
     - tableMetadata

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        schemaName=None,
        tableMetadata=None,
    ):
        self.catalogName = catalogName
        self.schemaName = schemaName
        self.tableMetadata = tableMetadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.schemaName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.tableMetadata = {}
                    (_ktype36, _vtype37, _size35) = iprot.readMapBegin()
                    for _i39 in range(_size35):
                        _key40 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val41 = []
                        (_etype45, _size42) = iprot.readListBegin()
                        for _i46 in range(_size42):
                            _elem47 = FieldMetadata()
                            _elem47.read(iprot)
                            _val41.append(_elem47)
                        iprot.readListEnd()
                        self.tableMetadata[_key40] = _val41
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("CatalogMetadata")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.schemaName is not None:
            oprot.writeFieldBegin("schemaName", TType.STRING, 2)
            oprot.writeString(
                self.schemaName.encode("utf-8") if sys.version_info[0] == 2 else self.schemaName
            )
            oprot.writeFieldEnd()
        if self.tableMetadata is not None:
            oprot.writeFieldBegin("tableMetadata", TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.tableMetadata))
            for kiter48, viter49 in self.tableMetadata.items():
                oprot.writeString(kiter48.encode("utf-8") if sys.version_info[0] == 2 else kiter48)
                oprot.writeListBegin(TType.STRUCT, len(viter49))
                for iter50 in viter49:
                    iter50.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeltaTableChangeResponse(object):
    """
    Attributes:
     - latestCheckpointVersion
     - latestLogVersion
     - lastKnownCheckpointVersion
     - lastKnownLogVersion
     - activePartitionsWithFiles
     - inactivePartitionsWithFiles
     - tableMetadata

    """

    thrift_spec = None

    def __init__(
        self,
        latestCheckpointVersion=None,
        latestLogVersion=None,
        lastKnownCheckpointVersion=None,
        lastKnownLogVersion=None,
        activePartitionsWithFiles=None,
        inactivePartitionsWithFiles=None,
        tableMetadata=None,
    ):
        self.latestCheckpointVersion = latestCheckpointVersion
        self.latestLogVersion = latestLogVersion
        self.lastKnownCheckpointVersion = lastKnownCheckpointVersion
        self.lastKnownLogVersion = lastKnownLogVersion
        self.activePartitionsWithFiles = activePartitionsWithFiles
        self.inactivePartitionsWithFiles = inactivePartitionsWithFiles
        self.tableMetadata = tableMetadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.latestCheckpointVersion = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.latestLogVersion = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.lastKnownCheckpointVersion = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.lastKnownLogVersion = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.activePartitionsWithFiles = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = e6_metadata_common.ttypes.E6Partition()
                        _elem56.read(iprot)
                        self.activePartitionsWithFiles.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.inactivePartitionsWithFiles = []
                    (_etype60, _size57) = iprot.readListBegin()
                    for _i61 in range(_size57):
                        _elem62 = e6_metadata_common.ttypes.E6Partition()
                        _elem62.read(iprot)
                        self.inactivePartitionsWithFiles.append(_elem62)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.tableMetadata = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("DeltaTableChangeResponse")
        if self.latestCheckpointVersion is not None:
            oprot.writeFieldBegin("latestCheckpointVersion", TType.I64, 1)
            oprot.writeI64(self.latestCheckpointVersion)
            oprot.writeFieldEnd()
        if self.latestLogVersion is not None:
            oprot.writeFieldBegin("latestLogVersion", TType.I64, 2)
            oprot.writeI64(self.latestLogVersion)
            oprot.writeFieldEnd()
        if self.lastKnownCheckpointVersion is not None:
            oprot.writeFieldBegin("lastKnownCheckpointVersion", TType.I64, 3)
            oprot.writeI64(self.lastKnownCheckpointVersion)
            oprot.writeFieldEnd()
        if self.lastKnownLogVersion is not None:
            oprot.writeFieldBegin("lastKnownLogVersion", TType.I64, 4)
            oprot.writeI64(self.lastKnownLogVersion)
            oprot.writeFieldEnd()
        if self.activePartitionsWithFiles is not None:
            oprot.writeFieldBegin("activePartitionsWithFiles", TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.activePartitionsWithFiles))
            for iter63 in self.activePartitionsWithFiles:
                iter63.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.inactivePartitionsWithFiles is not None:
            oprot.writeFieldBegin("inactivePartitionsWithFiles", TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.inactivePartitionsWithFiles))
            for iter64 in self.inactivePartitionsWithFiles:
                iter64.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tableMetadata is not None:
            oprot.writeFieldBegin("tableMetadata", TType.STRING, 7)
            oprot.writeBinary(self.tableMetadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UserContext(object):
    """
    Attributes:
     - userName
     - skipAuthz

    """

    thrift_spec = None

    def __init__(
        self,
        userName=None,
        skipAuthz=False,
    ):
        self.userName = userName
        self.skipAuthz = skipAuthz

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.skipAuthz = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("UserContext")
        if self.userName is not None:
            oprot.writeFieldBegin("userName", TType.STRING, 1)
            oprot.writeString(
                self.userName.encode("utf-8") if sys.version_info[0] == 2 else self.userName
            )
            oprot.writeFieldEnd()
        if self.skipAuthz is not None:
            oprot.writeFieldBegin("skipAuthz", TType.BOOL, 2)
            oprot.writeBool(self.skipAuthz)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetTablePartitionsResponse(object):
    """
    Attributes:
     - partitions
     - tableSizeInBytes
     - lastUpdateTimeMillis

    """

    thrift_spec = None

    def __init__(
        self,
        partitions=None,
        tableSizeInBytes=None,
        lastUpdateTimeMillis=None,
    ):
        self.partitions = partitions
        self.tableSizeInBytes = tableSizeInBytes
        self.lastUpdateTimeMillis = lastUpdateTimeMillis

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype68, _size65) = iprot.readListBegin()
                    for _i69 in range(_size65):
                        _elem70 = e6_metadata_common.ttypes.E6PartitionInfo()
                        _elem70.read(iprot)
                        self.partitions.append(_elem70)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.tableSizeInBytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.lastUpdateTimeMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("GetTablePartitionsResponse")
        if self.partitions is not None:
            oprot.writeFieldBegin("partitions", TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter71 in self.partitions:
                iter71.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tableSizeInBytes is not None:
            oprot.writeFieldBegin("tableSizeInBytes", TType.I64, 2)
            oprot.writeI64(self.tableSizeInBytes)
            oprot.writeFieldEnd()
        if self.lastUpdateTimeMillis is not None:
            oprot.writeFieldBegin("lastUpdateTimeMillis", TType.I64, 3)
            oprot.writeI64(self.lastUpdateTimeMillis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AnalyzedTableInfo(object):
    """
    Attributes:
     - ndvs

    """

    thrift_spec = None

    def __init__(
        self,
        ndvs=None,
    ):
        self.ndvs = ndvs

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.ndvs = {}
                    (_ktype73, _vtype74, _size72) = iprot.readMapBegin()
                    for _i76 in range(_size72):
                        _key77 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val78 = iprot.readI32()
                        self.ndvs[_key77] = _val78
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("AnalyzedTableInfo")
        if self.ndvs is not None:
            oprot.writeFieldBegin("ndvs", TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.ndvs))
            for kiter79, viter80 in self.ndvs.items():
                oprot.writeString(kiter79.encode("utf-8") if sys.version_info[0] == 2 else kiter79)
                oprot.writeI32(viter80)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableCallbackInfo(object):
    """
    Attributes:
     - dbName
     - tableName
     - payload

    """

    thrift_spec = None

    def __init__(
        self,
        dbName=None,
        tableName=None,
        payload=None,
    ):
        self.dbName = dbName
        self.tableName = tableName
        self.payload = payload

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.payload = TableCallbackPayload()
                    self.payload.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("TableCallbackInfo")
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 1)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 2)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin("payload", TType.STRUCT, 3)
            self.payload.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableCallbackPayload(object):
    """
    Attributes:
     - serialisedTable
     - errorMessage

    """

    thrift_spec = None

    def __init__(
        self,
        serialisedTable=None,
        errorMessage=None,
    ):
        self.serialisedTable = serialisedTable
        self.errorMessage = errorMessage

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serialisedTable = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errorMessage = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("TableCallbackPayload")
        if self.serialisedTable is not None:
            oprot.writeFieldBegin("serialisedTable", TType.STRING, 1)
            oprot.writeBinary(self.serialisedTable)
            oprot.writeFieldEnd()
        if self.errorMessage is not None:
            oprot.writeFieldBegin("errorMessage", TType.STRING, 2)
            oprot.writeString(
                self.errorMessage.encode("utf-8") if sys.version_info[0] == 2 else self.errorMessage
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CatalogDumpRequest(object):
    """
    Attributes:
     - requestedCatalogs

    """

    thrift_spec = None

    def __init__(
        self,
        requestedCatalogs=None,
    ):
        self.requestedCatalogs = requestedCatalogs

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.requestedCatalogs = []
                    (_etype84, _size81) = iprot.readListBegin()
                    for _i85 in range(_size81):
                        _elem86 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.requestedCatalogs.append(_elem86)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("CatalogDumpRequest")
        if self.requestedCatalogs is not None:
            oprot.writeFieldBegin("requestedCatalogs", TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.requestedCatalogs))
            for iter87 in self.requestedCatalogs:
                oprot.writeString(iter87.encode("utf-8") if sys.version_info[0] == 2 else iter87)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Dump(object):
    """
    Attributes:
     - catalogDump
     - convertedSchema
     - actionSummary

    """

    thrift_spec = None

    def __init__(
        self,
        catalogDump=None,
        convertedSchema=None,
        actionSummary=None,
    ):
        self.catalogDump = catalogDump
        self.convertedSchema = convertedSchema
        self.actionSummary = actionSummary

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogDump = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.convertedSchema = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.actionSummary = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("Dump")
        if self.catalogDump is not None:
            oprot.writeFieldBegin("catalogDump", TType.STRING, 1)
            oprot.writeBinary(self.catalogDump)
            oprot.writeFieldEnd()
        if self.convertedSchema is not None:
            oprot.writeFieldBegin("convertedSchema", TType.STRING, 2)
            oprot.writeBinary(self.convertedSchema)
            oprot.writeFieldEnd()
        if self.actionSummary is not None:
            oprot.writeFieldBegin("actionSummary", TType.STRING, 3)
            oprot.writeString(
                self.actionSummary.encode("utf-8")
                if sys.version_info[0] == 2
                else self.actionSummary
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Statistics(object):
    """
    Attributes:
     - rowCountOut
     - rowCountIn

    """

    thrift_spec = None

    def __init__(
        self,
        rowCountOut=None,
        rowCountIn=None,
    ):
        self.rowCountOut = rowCountOut
        self.rowCountIn = rowCountIn

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.rowCountOut = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.rowCountIn = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("Statistics")
        if self.rowCountOut is not None:
            oprot.writeFieldBegin("rowCountOut", TType.DOUBLE, 1)
            oprot.writeDouble(self.rowCountOut)
            oprot.writeFieldEnd()
        if self.rowCountIn is not None:
            oprot.writeFieldBegin("rowCountIn", TType.DOUBLE, 2)
            oprot.writeDouble(self.rowCountIn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableStatistics(object):
    """
    Attributes:
     - columnDistinctValues
     - columnNumNulls
     - rowCount

    """

    thrift_spec = None

    def __init__(
        self,
        columnDistinctValues=None,
        columnNumNulls=None,
        rowCount=None,
    ):
        self.columnDistinctValues = columnDistinctValues
        self.columnNumNulls = columnNumNulls
        self.rowCount = rowCount

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.columnDistinctValues = {}
                    (_ktype89, _vtype90, _size88) = iprot.readMapBegin()
                    for _i92 in range(_size88):
                        _key93 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val94 = iprot.readI64()
                        self.columnDistinctValues[_key93] = _val94
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.columnNumNulls = {}
                    (_ktype96, _vtype97, _size95) = iprot.readMapBegin()
                    for _i99 in range(_size95):
                        _key100 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val101 = iprot.readI64()
                        self.columnNumNulls[_key100] = _val101
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.rowCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("TableStatistics")
        if self.columnDistinctValues is not None:
            oprot.writeFieldBegin("columnDistinctValues", TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.columnDistinctValues))
            for kiter102, viter103 in self.columnDistinctValues.items():
                oprot.writeString(
                    kiter102.encode("utf-8") if sys.version_info[0] == 2 else kiter102
                )
                oprot.writeI64(viter103)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.columnNumNulls is not None:
            oprot.writeFieldBegin("columnNumNulls", TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.columnNumNulls))
            for kiter104, viter105 in self.columnNumNulls.items():
                oprot.writeString(
                    kiter104.encode("utf-8") if sys.version_info[0] == 2 else kiter104
                )
                oprot.writeI64(viter105)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.rowCount is not None:
            oprot.writeFieldBegin("rowCount", TType.I64, 3)
            oprot.writeI64(self.rowCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HBOStats(object):
    """
    Attributes:
     - statisticsList

    """

    thrift_spec = None

    def __init__(
        self,
        statisticsList=None,
    ):
        self.statisticsList = statisticsList

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.statisticsList = []
                    (_etype109, _size106) = iprot.readListBegin()
                    for _i110 in range(_size106):
                        _elem111 = Statistics()
                        _elem111.read(iprot)
                        self.statisticsList.append(_elem111)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("HBOStats")
        if self.statisticsList is not None:
            oprot.writeFieldBegin("statisticsList", TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.statisticsList))
            for iter112 in self.statisticsList:
                iter112.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DBObject(object):
    """
    Attributes:
     - dbObjectName
     - dbObjectType
     - columnNamesToTypeMap
     - tableProperties

    """

    thrift_spec = None

    def __init__(
        self,
        dbObjectName=None,
        dbObjectType=None,
        columnNamesToTypeMap=None,
        tableProperties=None,
    ):
        self.dbObjectName = dbObjectName
        self.dbObjectType = dbObjectType
        self.columnNamesToTypeMap = columnNamesToTypeMap
        self.tableProperties = tableProperties

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbObjectName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbObjectType = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.columnNamesToTypeMap = {}
                    (_ktype114, _vtype115, _size113) = iprot.readMapBegin()
                    for _i117 in range(_size113):
                        _key118 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val119 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.columnNamesToTypeMap[_key118] = _val119
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.tableProperties = {}
                    (_ktype121, _vtype122, _size120) = iprot.readMapBegin()
                    for _i124 in range(_size120):
                        _key125 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val126 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.tableProperties[_key125] = _val126
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("DBObject")
        if self.dbObjectName is not None:
            oprot.writeFieldBegin("dbObjectName", TType.STRING, 1)
            oprot.writeString(
                self.dbObjectName.encode("utf-8") if sys.version_info[0] == 2 else self.dbObjectName
            )
            oprot.writeFieldEnd()
        if self.dbObjectType is not None:
            oprot.writeFieldBegin("dbObjectType", TType.STRING, 2)
            oprot.writeString(
                self.dbObjectType.encode("utf-8") if sys.version_info[0] == 2 else self.dbObjectType
            )
            oprot.writeFieldEnd()
        if self.columnNamesToTypeMap is not None:
            oprot.writeFieldBegin("columnNamesToTypeMap", TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.columnNamesToTypeMap))
            for kiter127, viter128 in self.columnNamesToTypeMap.items():
                oprot.writeString(
                    kiter127.encode("utf-8") if sys.version_info[0] == 2 else kiter127
                )
                oprot.writeString(
                    viter128.encode("utf-8") if sys.version_info[0] == 2 else viter128
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tableProperties is not None:
            oprot.writeFieldBegin("tableProperties", TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tableProperties))
            for kiter129, viter130 in self.tableProperties.items():
                oprot.writeString(
                    kiter129.encode("utf-8") if sys.version_info[0] == 2 else kiter129
                )
                oprot.writeString(
                    viter130.encode("utf-8") if sys.version_info[0] == 2 else viter130
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(StorageServiceException)
StorageServiceException.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "reason",
        "UTF8",
        None,
    ),  # 1
)
all_structs.append(FailedSchemaElement)
FailedSchemaElement.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "type",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "reason",
        "UTF8",
        None,
    ),  # 3
)
all_structs.append(AddOrRefreshCatalogResponse)
AddOrRefreshCatalogResponse.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "status",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "failures",
        (TType.STRUCT, [FailedSchemaElement, None], False),
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "diagnosticsFilePath",
        "UTF8",
        None,
    ),  # 3
)
all_structs.append(StorageServiceRef)
StorageServiceRef.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "hostName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.I32,
        "port",
        None,
        None,
    ),  # 2
)
all_structs.append(BulkAddCatalogsResponse)
BulkAddCatalogsResponse.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "storageServiceRef",
        [StorageServiceRef, None],
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "catalogsAdditionStarted",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "failures",
        (TType.STRUCT, [FailedSchemaElement, None], False),
        None,
    ),  # 3
)
all_structs.append(RefreshDBsResponse)
RefreshDBsResponse.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "status",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.LIST,
        "failures",
        (TType.STRUCT, [FailedSchemaElement, None], False),
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "diagnosticsFilePath",
        "UTF8",
        None,
    ),  # 3
)
all_structs.append(FieldMetadata)
FieldMetadata.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "fieldName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "fieldType",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "childFields",
        (TType.STRUCT, [FieldMetadata, None], False),
        None,
    ),  # 3
)
all_structs.append(CatalogMetadata)
CatalogMetadata.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "schemaName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.MAP,
        "tableMetadata",
        (TType.STRING, "UTF8", TType.LIST, (TType.STRUCT, [FieldMetadata, None], False), False),
        None,
    ),  # 3
)
all_structs.append(DeltaTableChangeResponse)
DeltaTableChangeResponse.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I64,
        "latestCheckpointVersion",
        None,
        None,
    ),  # 1
    (
        2,
        TType.I64,
        "latestLogVersion",
        None,
        None,
    ),  # 2
    (
        3,
        TType.I64,
        "lastKnownCheckpointVersion",
        None,
        None,
    ),  # 3
    (
        4,
        TType.I64,
        "lastKnownLogVersion",
        None,
        None,
    ),  # 4
    (
        5,
        TType.LIST,
        "activePartitionsWithFiles",
        (TType.STRUCT, [e6_metadata_common.ttypes.E6Partition, None], False),
        None,
    ),  # 5
    (
        6,
        TType.LIST,
        "inactivePartitionsWithFiles",
        (TType.STRUCT, [e6_metadata_common.ttypes.E6Partition, None], False),
        None,
    ),  # 6
    (
        7,
        TType.STRING,
        "tableMetadata",
        "BINARY",
        None,
    ),  # 7
)
all_structs.append(UserContext)
UserContext.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "userName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.BOOL,
        "skipAuthz",
        None,
        False,
    ),  # 2
)
all_structs.append(GetTablePartitionsResponse)
GetTablePartitionsResponse.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "partitions",
        (TType.STRUCT, [e6_metadata_common.ttypes.E6PartitionInfo, None], False),
        None,
    ),  # 1
    (
        2,
        TType.I64,
        "tableSizeInBytes",
        None,
        None,
    ),  # 2
    (
        3,
        TType.I64,
        "lastUpdateTimeMillis",
        None,
        None,
    ),  # 3
)
all_structs.append(AnalyzedTableInfo)
AnalyzedTableInfo.thrift_spec = (
    None,  # 0
    (
        1,
        TType.MAP,
        "ndvs",
        (TType.STRING, "UTF8", TType.I32, None, False),
        None,
    ),  # 1
)
all_structs.append(TableCallbackInfo)
TableCallbackInfo.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "payload",
        [TableCallbackPayload, None],
        None,
    ),  # 3
)
all_structs.append(TableCallbackPayload)
TableCallbackPayload.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "serialisedTable",
        "BINARY",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "errorMessage",
        "UTF8",
        None,
    ),  # 2
)
all_structs.append(CatalogDumpRequest)
CatalogDumpRequest.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "requestedCatalogs",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 1
)
all_structs.append(Dump)
Dump.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogDump",
        "BINARY",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "convertedSchema",
        "BINARY",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "actionSummary",
        "UTF8",
        None,
    ),  # 3
)
all_structs.append(Statistics)
Statistics.thrift_spec = (
    None,  # 0
    (
        1,
        TType.DOUBLE,
        "rowCountOut",
        None,
        None,
    ),  # 1
    (
        2,
        TType.DOUBLE,
        "rowCountIn",
        None,
        None,
    ),  # 2
)
all_structs.append(TableStatistics)
TableStatistics.thrift_spec = (
    None,  # 0
    (
        1,
        TType.MAP,
        "columnDistinctValues",
        (TType.STRING, "UTF8", TType.I64, None, False),
        None,
    ),  # 1
    (
        2,
        TType.MAP,
        "columnNumNulls",
        (TType.STRING, "UTF8", TType.I64, None, False),
        None,
    ),  # 2
    (
        3,
        TType.I64,
        "rowCount",
        None,
        None,
    ),  # 3
)
all_structs.append(HBOStats)
HBOStats.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "statisticsList",
        (TType.STRUCT, [Statistics, None], False),
        None,
    ),  # 1
)
all_structs.append(DBObject)
DBObject.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "dbObjectName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbObjectType",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.MAP,
        "columnNamesToTypeMap",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.MAP,
        "tableProperties",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 4
)
fix_spec(all_structs)
del all_structs
