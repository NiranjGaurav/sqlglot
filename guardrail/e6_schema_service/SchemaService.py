#
# Autogenerated by Thrift Compiler (0.21.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import logging

import guardrail
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport

all_structs = []


class Iface(object):
    def getDBNamesForCatalog(self, catalogName, connectionMetadata):
        """
        Parameters:
         - catalogName
         - connectionMetadata

        """
        pass

    def getTableNamesForDB(self, catalogName, dbName, connectionMetadata):
        """
        Parameters:
         - catalogName
         - dbName
         - connectionMetadata

        """
        pass

    def getTableMetadataForTables(self, catalogName, dbName, tableNames, connectionMetadata):
        """
        Parameters:
         - catalogName
         - dbName
         - tableNames
         - connectionMetadata

        """
        pass

    def getDBNames(self, catalogName, connectionMetadata, requestContext):
        """
        Parameters:
         - catalogName
         - connectionMetadata
         - requestContext

        """
        pass

    def getTableNames(self, catalogName, dbName, connectionMetadata, requestContext):
        """
        Parameters:
         - catalogName
         - dbName
         - connectionMetadata
         - requestContext

        """
        pass

    def getTableMetadata(self, catalogName, dbName, tableNames, connectionMetadata, requestContext):
        """
        Parameters:
         - catalogName
         - dbName
         - tableNames
         - connectionMetadata
         - requestContext

        """
        pass

    def getTableStatistics(
        self, catalogName, dbName, tableName, connectionMetadata, requestContext
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - connectionMetadata
         - requestContext

        """
        pass

    def getTablePartitions(
        self, catalogName, dbName, tableName, connectionMetadata, requestContext
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - connectionMetadata
         - requestContext

        """
        pass

    def getTableFilePaths(
        self, catalogName, dbName, tableName, partitions, connectionMetadata, requestContext
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - partitions
         - connectionMetadata
         - requestContext

        """
        pass

    def getFileMetadata(self, fileStatus, connectionMetadata, requestContext):
        """
        Parameters:
         - fileStatus
         - connectionMetadata
         - requestContext

        """
        pass

    def getAdditionalData(
        self,
        catalogName,
        dbName,
        tableName,
        partitions,
        connectionMetadata,
        snopShotVersion,
        requestContext,
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - partitions
         - connectionMetadata
         - snopShotVersion
         - requestContext

        """
        pass

    def calculateStats(
        self,
        catalogName,
        dbName,
        tableName,
        columnNames,
        partFilesToAnalyze,
        connectionMetadata,
        requestContext,
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - columnNames
         - partFilesToAnalyze
         - connectionMetadata
         - requestContext

        """
        pass

    def getTablePartitionsForDelta(
        self,
        catalogName,
        dbName,
        tableName,
        deltaTablePartitionInfo,
        tableVersionInfo,
        connectionMetadata,
        requestContext,
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - deltaTablePartitionInfo
         - tableVersionInfo
         - connectionMetadata
         - requestContext

        """
        pass

    def getMetastoreUsers(self, connectionMetadata, requestContext):
        """
        Parameters:
         - connectionMetadata
         - requestContext

        """
        pass

    def getMetastoreGroups(self, connectionMetadata, requestContext):
        """
        Parameters:
         - connectionMetadata
         - requestContext

        """
        pass

    def getMetastorePermissions_catalog(self, connectionMetadata, requestContext, catalog):
        """
        Parameters:
         - connectionMetadata
         - requestContext
         - catalog

        """
        pass

    def getMetastorePermissions_schema(self, connectionMetadata, requestContext, catalog, schema):
        """
        Parameters:
         - connectionMetadata
         - requestContext
         - catalog
         - schema

        """
        pass

    def getMetastorePermissions_table(
        self, connectionMetadata, requestContext, catalog, schema, table
    ):
        """
        Parameters:
         - connectionMetadata
         - requestContext
         - catalog
         - schema
         - table

        """
        pass

    def createView(self, connectionMetadata, catalogName, dbName, tableName, requestContext, bytes):
        """
        Parameters:
         - connectionMetadata
         - catalogName
         - dbName
         - tableName
         - requestContext
         - bytes

        """
        pass

    def updateView(
        self, connectionMetadata, catalogName, databaseName, tableName, bytes, requestContext
    ):
        """
        Parameters:
         - connectionMetadata
         - catalogName
         - databaseName
         - tableName
         - bytes
         - requestContext

        """
        pass

    def dropView(self, connectionMetadata, catalogName, dbName, tableName, requestContext):
        """
        Parameters:
         - connectionMetadata
         - catalogName
         - dbName
         - tableName
         - requestContext

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getDBNamesForCatalog(self, catalogName, connectionMetadata):
        """
        Parameters:
         - catalogName
         - connectionMetadata

        """
        self.send_getDBNamesForCatalog(catalogName, connectionMetadata)
        return self.recv_getDBNamesForCatalog()

    def send_getDBNamesForCatalog(self, catalogName, connectionMetadata):
        self._oprot.writeMessageBegin("getDBNamesForCatalog", TMessageType.CALL, self._seqid)
        args = getDBNamesForCatalog_args()
        args.catalogName = catalogName
        args.connectionMetadata = connectionMetadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDBNamesForCatalog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDBNamesForCatalog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getDBNamesForCatalog failed: unknown result"
        )

    def getTableNamesForDB(self, catalogName, dbName, connectionMetadata):
        """
        Parameters:
         - catalogName
         - dbName
         - connectionMetadata

        """
        self.send_getTableNamesForDB(catalogName, dbName, connectionMetadata)
        return self.recv_getTableNamesForDB()

    def send_getTableNamesForDB(self, catalogName, dbName, connectionMetadata):
        self._oprot.writeMessageBegin("getTableNamesForDB", TMessageType.CALL, self._seqid)
        args = getTableNamesForDB_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.connectionMetadata = connectionMetadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableNamesForDB(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableNamesForDB_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getTableNamesForDB failed: unknown result"
        )

    def getTableMetadataForTables(self, catalogName, dbName, tableNames, connectionMetadata):
        """
        Parameters:
         - catalogName
         - dbName
         - tableNames
         - connectionMetadata

        """
        self.send_getTableMetadataForTables(catalogName, dbName, tableNames, connectionMetadata)
        return self.recv_getTableMetadataForTables()

    def send_getTableMetadataForTables(self, catalogName, dbName, tableNames, connectionMetadata):
        self._oprot.writeMessageBegin("getTableMetadataForTables", TMessageType.CALL, self._seqid)
        args = getTableMetadataForTables_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableNames = tableNames
        args.connectionMetadata = connectionMetadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableMetadataForTables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableMetadataForTables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getTableMetadataForTables failed: unknown result"
        )

    def getDBNames(self, catalogName, connectionMetadata, requestContext):
        """
        Parameters:
         - catalogName
         - connectionMetadata
         - requestContext

        """
        self.send_getDBNames(catalogName, connectionMetadata, requestContext)
        self.recv_getDBNames()

    def send_getDBNames(self, catalogName, connectionMetadata, requestContext):
        self._oprot.writeMessageBegin("getDBNames", TMessageType.CALL, self._seqid)
        args = getDBNames_args()
        args.catalogName = catalogName
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDBNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDBNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def getTableNames(self, catalogName, dbName, connectionMetadata, requestContext):
        """
        Parameters:
         - catalogName
         - dbName
         - connectionMetadata
         - requestContext

        """
        self.send_getTableNames(catalogName, dbName, connectionMetadata, requestContext)
        self.recv_getTableNames()

    def send_getTableNames(self, catalogName, dbName, connectionMetadata, requestContext):
        self._oprot.writeMessageBegin("getTableNames", TMessageType.CALL, self._seqid)
        args = getTableNames_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def getTableMetadata(self, catalogName, dbName, tableNames, connectionMetadata, requestContext):
        """
        Parameters:
         - catalogName
         - dbName
         - tableNames
         - connectionMetadata
         - requestContext

        """
        self.send_getTableMetadata(
            catalogName, dbName, tableNames, connectionMetadata, requestContext
        )
        self.recv_getTableMetadata()

    def send_getTableMetadata(
        self, catalogName, dbName, tableNames, connectionMetadata, requestContext
    ):
        self._oprot.writeMessageBegin("getTableMetadata", TMessageType.CALL, self._seqid)
        args = getTableMetadata_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableNames = tableNames
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def getTableStatistics(
        self, catalogName, dbName, tableName, connectionMetadata, requestContext
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - connectionMetadata
         - requestContext

        """
        self.send_getTableStatistics(
            catalogName, dbName, tableName, connectionMetadata, requestContext
        )
        self.recv_getTableStatistics()

    def send_getTableStatistics(
        self, catalogName, dbName, tableName, connectionMetadata, requestContext
    ):
        self._oprot.writeMessageBegin("getTableStatistics", TMessageType.CALL, self._seqid)
        args = getTableStatistics_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableStatistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableStatistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def getTablePartitions(
        self, catalogName, dbName, tableName, connectionMetadata, requestContext
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - connectionMetadata
         - requestContext

        """
        self.send_getTablePartitions(
            catalogName, dbName, tableName, connectionMetadata, requestContext
        )
        self.recv_getTablePartitions()

    def send_getTablePartitions(
        self, catalogName, dbName, tableName, connectionMetadata, requestContext
    ):
        self._oprot.writeMessageBegin("getTablePartitions", TMessageType.CALL, self._seqid)
        args = getTablePartitions_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTablePartitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTablePartitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def getTableFilePaths(
        self, catalogName, dbName, tableName, partitions, connectionMetadata, requestContext
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - partitions
         - connectionMetadata
         - requestContext

        """
        self.send_getTableFilePaths(
            catalogName, dbName, tableName, partitions, connectionMetadata, requestContext
        )
        self.recv_getTableFilePaths()

    def send_getTableFilePaths(
        self, catalogName, dbName, tableName, partitions, connectionMetadata, requestContext
    ):
        self._oprot.writeMessageBegin("getTableFilePaths", TMessageType.CALL, self._seqid)
        args = getTableFilePaths_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.partitions = partitions
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableFilePaths(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableFilePaths_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def getFileMetadata(self, fileStatus, connectionMetadata, requestContext):
        """
        Parameters:
         - fileStatus
         - connectionMetadata
         - requestContext

        """
        self.send_getFileMetadata(fileStatus, connectionMetadata, requestContext)
        self.recv_getFileMetadata()

    def send_getFileMetadata(self, fileStatus, connectionMetadata, requestContext):
        self._oprot.writeMessageBegin("getFileMetadata", TMessageType.CALL, self._seqid)
        args = getFileMetadata_args()
        args.fileStatus = fileStatus
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFileMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFileMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def getAdditionalData(
        self,
        catalogName,
        dbName,
        tableName,
        partitions,
        connectionMetadata,
        snopShotVersion,
        requestContext,
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - partitions
         - connectionMetadata
         - snopShotVersion
         - requestContext

        """
        self.send_getAdditionalData(
            catalogName,
            dbName,
            tableName,
            partitions,
            connectionMetadata,
            snopShotVersion,
            requestContext,
        )
        self.recv_getAdditionalData()

    def send_getAdditionalData(
        self,
        catalogName,
        dbName,
        tableName,
        partitions,
        connectionMetadata,
        snopShotVersion,
        requestContext,
    ):
        self._oprot.writeMessageBegin("getAdditionalData", TMessageType.CALL, self._seqid)
        args = getAdditionalData_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.partitions = partitions
        args.connectionMetadata = connectionMetadata
        args.snopShotVersion = snopShotVersion
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAdditionalData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAdditionalData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def calculateStats(
        self,
        catalogName,
        dbName,
        tableName,
        columnNames,
        partFilesToAnalyze,
        connectionMetadata,
        requestContext,
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - columnNames
         - partFilesToAnalyze
         - connectionMetadata
         - requestContext

        """
        self.send_calculateStats(
            catalogName,
            dbName,
            tableName,
            columnNames,
            partFilesToAnalyze,
            connectionMetadata,
            requestContext,
        )
        return self.recv_calculateStats()

    def send_calculateStats(
        self,
        catalogName,
        dbName,
        tableName,
        columnNames,
        partFilesToAnalyze,
        connectionMetadata,
        requestContext,
    ):
        self._oprot.writeMessageBegin("calculateStats", TMessageType.CALL, self._seqid)
        args = calculateStats_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.columnNames = columnNames
        args.partFilesToAnalyze = partFilesToAnalyze
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_calculateStats(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = calculateStats_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "calculateStats failed: unknown result"
        )

    def getTablePartitionsForDelta(
        self,
        catalogName,
        dbName,
        tableName,
        deltaTablePartitionInfo,
        tableVersionInfo,
        connectionMetadata,
        requestContext,
    ):
        """
        Parameters:
         - catalogName
         - dbName
         - tableName
         - deltaTablePartitionInfo
         - tableVersionInfo
         - connectionMetadata
         - requestContext

        """
        self.send_getTablePartitionsForDelta(
            catalogName,
            dbName,
            tableName,
            deltaTablePartitionInfo,
            tableVersionInfo,
            connectionMetadata,
            requestContext,
        )
        self.recv_getTablePartitionsForDelta()

    def send_getTablePartitionsForDelta(
        self,
        catalogName,
        dbName,
        tableName,
        deltaTablePartitionInfo,
        tableVersionInfo,
        connectionMetadata,
        requestContext,
    ):
        self._oprot.writeMessageBegin("getTablePartitionsForDelta", TMessageType.CALL, self._seqid)
        args = getTablePartitionsForDelta_args()
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.deltaTablePartitionInfo = deltaTablePartitionInfo
        args.tableVersionInfo = tableVersionInfo
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTablePartitionsForDelta(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTablePartitionsForDelta_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def getMetastoreUsers(self, connectionMetadata, requestContext):
        """
        Parameters:
         - connectionMetadata
         - requestContext

        """
        self.send_getMetastoreUsers(connectionMetadata, requestContext)
        return self.recv_getMetastoreUsers()

    def send_getMetastoreUsers(self, connectionMetadata, requestContext):
        self._oprot.writeMessageBegin("getMetastoreUsers", TMessageType.CALL, self._seqid)
        args = getMetastoreUsers_args()
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMetastoreUsers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMetastoreUsers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getMetastoreUsers failed: unknown result"
        )

    def getMetastoreGroups(self, connectionMetadata, requestContext):
        """
        Parameters:
         - connectionMetadata
         - requestContext

        """
        self.send_getMetastoreGroups(connectionMetadata, requestContext)
        return self.recv_getMetastoreGroups()

    def send_getMetastoreGroups(self, connectionMetadata, requestContext):
        self._oprot.writeMessageBegin("getMetastoreGroups", TMessageType.CALL, self._seqid)
        args = getMetastoreGroups_args()
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMetastoreGroups(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMetastoreGroups_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getMetastoreGroups failed: unknown result"
        )

    def getMetastorePermissions_catalog(self, connectionMetadata, requestContext, catalog):
        """
        Parameters:
         - connectionMetadata
         - requestContext
         - catalog

        """
        self.send_getMetastorePermissions_catalog(connectionMetadata, requestContext, catalog)
        return self.recv_getMetastorePermissions_catalog()

    def send_getMetastorePermissions_catalog(self, connectionMetadata, requestContext, catalog):
        self._oprot.writeMessageBegin(
            "getMetastorePermissions_catalog", TMessageType.CALL, self._seqid
        )
        args = getMetastorePermissions_catalog_args()
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.catalog = catalog
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMetastorePermissions_catalog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMetastorePermissions_catalog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getMetastorePermissions_catalog failed: unknown result",
        )

    def getMetastorePermissions_schema(self, connectionMetadata, requestContext, catalog, schema):
        """
        Parameters:
         - connectionMetadata
         - requestContext
         - catalog
         - schema

        """
        self.send_getMetastorePermissions_schema(
            connectionMetadata, requestContext, catalog, schema
        )
        return self.recv_getMetastorePermissions_schema()

    def send_getMetastorePermissions_schema(
        self, connectionMetadata, requestContext, catalog, schema
    ):
        self._oprot.writeMessageBegin(
            "getMetastorePermissions_schema", TMessageType.CALL, self._seqid
        )
        args = getMetastorePermissions_schema_args()
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.catalog = catalog
        args.schema = schema
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMetastorePermissions_schema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMetastorePermissions_schema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getMetastorePermissions_schema failed: unknown result",
        )

    def getMetastorePermissions_table(
        self, connectionMetadata, requestContext, catalog, schema, table
    ):
        """
        Parameters:
         - connectionMetadata
         - requestContext
         - catalog
         - schema
         - table

        """
        self.send_getMetastorePermissions_table(
            connectionMetadata, requestContext, catalog, schema, table
        )
        return self.recv_getMetastorePermissions_table()

    def send_getMetastorePermissions_table(
        self, connectionMetadata, requestContext, catalog, schema, table
    ):
        self._oprot.writeMessageBegin(
            "getMetastorePermissions_table", TMessageType.CALL, self._seqid
        )
        args = getMetastorePermissions_table_args()
        args.connectionMetadata = connectionMetadata
        args.requestContext = requestContext
        args.catalog = catalog
        args.schema = schema
        args.table = table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMetastorePermissions_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMetastorePermissions_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getMetastorePermissions_table failed: unknown result",
        )

    def createView(self, connectionMetadata, catalogName, dbName, tableName, requestContext, bytes):
        """
        Parameters:
         - connectionMetadata
         - catalogName
         - dbName
         - tableName
         - requestContext
         - bytes

        """
        self.send_createView(
            connectionMetadata, catalogName, dbName, tableName, requestContext, bytes
        )
        self.recv_createView()

    def send_createView(
        self, connectionMetadata, catalogName, dbName, tableName, requestContext, bytes
    ):
        self._oprot.writeMessageBegin("createView", TMessageType.CALL, self._seqid)
        args = createView_args()
        args.connectionMetadata = connectionMetadata
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.requestContext = requestContext
        args.bytes = bytes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def updateView(
        self, connectionMetadata, catalogName, databaseName, tableName, bytes, requestContext
    ):
        """
        Parameters:
         - connectionMetadata
         - catalogName
         - databaseName
         - tableName
         - bytes
         - requestContext

        """
        self.send_updateView(
            connectionMetadata, catalogName, databaseName, tableName, bytes, requestContext
        )
        self.recv_updateView()

    def send_updateView(
        self, connectionMetadata, catalogName, databaseName, tableName, bytes, requestContext
    ):
        self._oprot.writeMessageBegin("updateView", TMessageType.CALL, self._seqid)
        args = updateView_args()
        args.connectionMetadata = connectionMetadata
        args.catalogName = catalogName
        args.databaseName = databaseName
        args.tableName = tableName
        args.bytes = bytes
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return

    def dropView(self, connectionMetadata, catalogName, dbName, tableName, requestContext):
        """
        Parameters:
         - connectionMetadata
         - catalogName
         - dbName
         - tableName
         - requestContext

        """
        self.send_dropView(connectionMetadata, catalogName, dbName, tableName, requestContext)
        self.recv_dropView()

    def send_dropView(self, connectionMetadata, catalogName, dbName, tableName, requestContext):
        self._oprot.writeMessageBegin("dropView", TMessageType.CALL, self._seqid)
        args = dropView_args()
        args.connectionMetadata = connectionMetadata
        args.catalogName = catalogName
        args.dbName = dbName
        args.tableName = tableName
        args.requestContext = requestContext
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dropView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dropView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getDBNamesForCatalog"] = Processor.process_getDBNamesForCatalog
        self._processMap["getTableNamesForDB"] = Processor.process_getTableNamesForDB
        self._processMap["getTableMetadataForTables"] = Processor.process_getTableMetadataForTables
        self._processMap["getDBNames"] = Processor.process_getDBNames
        self._processMap["getTableNames"] = Processor.process_getTableNames
        self._processMap["getTableMetadata"] = Processor.process_getTableMetadata
        self._processMap["getTableStatistics"] = Processor.process_getTableStatistics
        self._processMap["getTablePartitions"] = Processor.process_getTablePartitions
        self._processMap["getTableFilePaths"] = Processor.process_getTableFilePaths
        self._processMap["getFileMetadata"] = Processor.process_getFileMetadata
        self._processMap["getAdditionalData"] = Processor.process_getAdditionalData
        self._processMap["calculateStats"] = Processor.process_calculateStats
        self._processMap["getTablePartitionsForDelta"] = (
            Processor.process_getTablePartitionsForDelta
        )
        self._processMap["getMetastoreUsers"] = Processor.process_getMetastoreUsers
        self._processMap["getMetastoreGroups"] = Processor.process_getMetastoreGroups
        self._processMap["getMetastorePermissions_catalog"] = (
            Processor.process_getMetastorePermissions_catalog
        )
        self._processMap["getMetastorePermissions_schema"] = (
            Processor.process_getMetastorePermissions_schema
        )
        self._processMap["getMetastorePermissions_table"] = (
            Processor.process_getMetastorePermissions_table
        )
        self._processMap["createView"] = Processor.process_createView
        self._processMap["updateView"] = Processor.process_updateView
        self._processMap["dropView"] = Processor.process_dropView
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(
                TApplicationException.UNKNOWN_METHOD, "Unknown function %s" % (name)
            )
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getDBNamesForCatalog(self, seqid, iprot, oprot):
        args = getDBNamesForCatalog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDBNamesForCatalog_result()
        try:
            result.success = self._handler.getDBNamesForCatalog(
                args.catalogName, args.connectionMetadata
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getDBNamesForCatalog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableNamesForDB(self, seqid, iprot, oprot):
        args = getTableNamesForDB_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableNamesForDB_result()
        try:
            result.success = self._handler.getTableNamesForDB(
                args.catalogName, args.dbName, args.connectionMetadata
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableNamesForDB", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableMetadataForTables(self, seqid, iprot, oprot):
        args = getTableMetadataForTables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableMetadataForTables_result()
        try:
            result.success = self._handler.getTableMetadataForTables(
                args.catalogName, args.dbName, args.tableNames, args.connectionMetadata
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableMetadataForTables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDBNames(self, seqid, iprot, oprot):
        args = getDBNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDBNames_result()
        try:
            self._handler.getDBNames(args.catalogName, args.connectionMetadata, args.requestContext)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getDBNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableNames(self, seqid, iprot, oprot):
        args = getTableNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableNames_result()
        try:
            self._handler.getTableNames(
                args.catalogName, args.dbName, args.connectionMetadata, args.requestContext
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableMetadata(self, seqid, iprot, oprot):
        args = getTableMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableMetadata_result()
        try:
            self._handler.getTableMetadata(
                args.catalogName,
                args.dbName,
                args.tableNames,
                args.connectionMetadata,
                args.requestContext,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableStatistics(self, seqid, iprot, oprot):
        args = getTableStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableStatistics_result()
        try:
            self._handler.getTableStatistics(
                args.catalogName,
                args.dbName,
                args.tableName,
                args.connectionMetadata,
                args.requestContext,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableStatistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTablePartitions(self, seqid, iprot, oprot):
        args = getTablePartitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTablePartitions_result()
        try:
            self._handler.getTablePartitions(
                args.catalogName,
                args.dbName,
                args.tableName,
                args.connectionMetadata,
                args.requestContext,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTablePartitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableFilePaths(self, seqid, iprot, oprot):
        args = getTableFilePaths_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableFilePaths_result()
        try:
            self._handler.getTableFilePaths(
                args.catalogName,
                args.dbName,
                args.tableName,
                args.partitions,
                args.connectionMetadata,
                args.requestContext,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTableFilePaths", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFileMetadata(self, seqid, iprot, oprot):
        args = getFileMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFileMetadata_result()
        try:
            self._handler.getFileMetadata(
                args.fileStatus, args.connectionMetadata, args.requestContext
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getFileMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAdditionalData(self, seqid, iprot, oprot):
        args = getAdditionalData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAdditionalData_result()
        try:
            self._handler.getAdditionalData(
                args.catalogName,
                args.dbName,
                args.tableName,
                args.partitions,
                args.connectionMetadata,
                args.snopShotVersion,
                args.requestContext,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getAdditionalData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_calculateStats(self, seqid, iprot, oprot):
        args = calculateStats_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = calculateStats_result()
        try:
            result.success = self._handler.calculateStats(
                args.catalogName,
                args.dbName,
                args.tableName,
                args.columnNames,
                args.partFilesToAnalyze,
                args.connectionMetadata,
                args.requestContext,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("calculateStats", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTablePartitionsForDelta(self, seqid, iprot, oprot):
        args = getTablePartitionsForDelta_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTablePartitionsForDelta_result()
        try:
            self._handler.getTablePartitionsForDelta(
                args.catalogName,
                args.dbName,
                args.tableName,
                args.deltaTablePartitionInfo,
                args.tableVersionInfo,
                args.connectionMetadata,
                args.requestContext,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getTablePartitionsForDelta", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMetastoreUsers(self, seqid, iprot, oprot):
        args = getMetastoreUsers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMetastoreUsers_result()
        try:
            result.success = self._handler.getMetastoreUsers(
                args.connectionMetadata, args.requestContext
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getMetastoreUsers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMetastoreGroups(self, seqid, iprot, oprot):
        args = getMetastoreGroups_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMetastoreGroups_result()
        try:
            result.success = self._handler.getMetastoreGroups(
                args.connectionMetadata, args.requestContext
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getMetastoreGroups", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMetastorePermissions_catalog(self, seqid, iprot, oprot):
        args = getMetastorePermissions_catalog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMetastorePermissions_catalog_result()
        try:
            result.success = self._handler.getMetastorePermissions_catalog(
                args.connectionMetadata, args.requestContext, args.catalog
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getMetastorePermissions_catalog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMetastorePermissions_schema(self, seqid, iprot, oprot):
        args = getMetastorePermissions_schema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMetastorePermissions_schema_result()
        try:
            result.success = self._handler.getMetastorePermissions_schema(
                args.connectionMetadata, args.requestContext, args.catalog, args.schema
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getMetastorePermissions_schema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMetastorePermissions_table(self, seqid, iprot, oprot):
        args = getMetastorePermissions_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMetastorePermissions_table_result()
        try:
            result.success = self._handler.getMetastorePermissions_table(
                args.connectionMetadata, args.requestContext, args.catalog, args.schema, args.table
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("getMetastorePermissions_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createView(self, seqid, iprot, oprot):
        args = createView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createView_result()
        try:
            self._handler.createView(
                args.connectionMetadata,
                args.catalogName,
                args.dbName,
                args.tableName,
                args.requestContext,
                args.bytes,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("createView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateView(self, seqid, iprot, oprot):
        args = updateView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateView_result()
        try:
            self._handler.updateView(
                args.connectionMetadata,
                args.catalogName,
                args.databaseName,
                args.tableName,
                args.bytes,
                args.requestContext,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("updateView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dropView(self, seqid, iprot, oprot):
        args = dropView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dropView_result()
        try:
            self._handler.dropView(
                args.connectionMetadata,
                args.catalogName,
                args.dbName,
                args.tableName,
                args.requestContext,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SchemaServiceException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error")
        oprot.writeMessageBegin("dropView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES


class getDBNamesForCatalog_args(object):
    """
    Attributes:
     - catalogName
     - connectionMetadata

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        connectionMetadata=None,
    ):
        self.catalogName = catalogName
        self.connectionMetadata = connectionMetadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBNamesForCatalog_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 2)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBNamesForCatalog_args)
getDBNamesForCatalog_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 2
)


class getDBNamesForCatalog_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype77, _size74) = iprot.readListBegin()
                    for _i78 in range(_size74):
                        _elem79 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem79)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBNamesForCatalog_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter80 in self.success:
                oprot.writeString(iter80.encode("utf-8") if sys.version_info[0] == 2 else iter80)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBNamesForCatalog_result)
getDBNamesForCatalog_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getTableNamesForDB_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - connectionMetadata

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        connectionMetadata=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.connectionMetadata = connectionMetadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableNamesForDB_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 3)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableNamesForDB_args)
getTableNamesForDB_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 3
)


class getTableNamesForDB_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype84, _size81) = iprot.readListBegin()
                    for _i85 in range(_size81):
                        _elem86 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem86)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableNamesForDB_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter87 in self.success:
                oprot.writeString(iter87.encode("utf-8") if sys.version_info[0] == 2 else iter87)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableNamesForDB_result)
getTableNamesForDB_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getTableMetadataForTables_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableNames
     - connectionMetadata

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableNames=None,
        connectionMetadata=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableNames = tableNames
        self.connectionMetadata = connectionMetadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tableNames = []
                    (_etype91, _size88) = iprot.readListBegin()
                    for _i92 in range(_size88):
                        _elem93 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.tableNames.append(_elem93)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableMetadataForTables_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableNames is not None:
            oprot.writeFieldBegin("tableNames", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.tableNames))
            for iter94 in self.tableNames:
                oprot.writeString(iter94.encode("utf-8") if sys.version_info[0] == 2 else iter94)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 4)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableMetadataForTables_args)
getTableMetadataForTables_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "tableNames",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 4
)


class getTableMetadataForTables_result(object):
    """
    Attributes:
     - success
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        error1=None,
    ):
        self.success = success
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype98, _size95) = iprot.readListBegin()
                    for _i99 in range(_size95):
                        _elem100 = TableMetadataResponse()
                        _elem100.read(iprot)
                        self.success.append(_elem100)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableMetadataForTables_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter101 in self.success:
                iter101.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableMetadataForTables_result)
getTableMetadataForTables_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [TableMetadataResponse, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getDBNames_args(object):
    """
    Attributes:
     - catalogName
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.catalogName = catalogName
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBNames_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 2)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 3)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBNames_args)
getDBNames_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 3
)


class getDBNames_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getDBNames_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getDBNames_result)
getDBNames_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getTableNames_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableNames_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 3)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 4)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableNames_args)
getTableNames_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 4
)


class getTableNames_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableNames_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableNames_result)
getTableNames_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getTableMetadata_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableNames
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableNames=None,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableNames = tableNames
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tableNames = []
                    (_etype105, _size102) = iprot.readListBegin()
                    for _i106 in range(_size102):
                        _elem107 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.tableNames.append(_elem107)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableMetadata_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableNames is not None:
            oprot.writeFieldBegin("tableNames", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.tableNames))
            for iter108 in self.tableNames:
                oprot.writeString(iter108.encode("utf-8") if sys.version_info[0] == 2 else iter108)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 4)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 5)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableMetadata_args)
getTableMetadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "tableNames",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 5
)


class getTableMetadata_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableMetadata_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableMetadata_result)
getTableMetadata_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getTableStatistics_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableStatistics_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 4)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 5)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableStatistics_args)
getTableStatistics_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 5
)


class getTableStatistics_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableStatistics_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableStatistics_result)
getTableStatistics_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getTablePartitions_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitions_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 4)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 5)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitions_args)
getTablePartitions_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 5
)


class getTablePartitions_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitions_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitions_result)
getTablePartitions_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getTableFilePaths_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - partitions
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        partitions=None,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.partitions = partitions
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype112, _size109) = iprot.readListBegin()
                    for _i113 in range(_size109):
                        _elem114 = guardrail.e6_metadata_common.ttypes.E6Partition()
                        _elem114.read(iprot)
                        self.partitions.append(_elem114)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableFilePaths_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin("partitions", TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter115 in self.partitions:
                iter115.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 5)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 6)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableFilePaths_args)
getTableFilePaths_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "partitions",
        (TType.STRUCT, [guardrail.e6_metadata_common.ttypes.E6Partition, None], False),
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 5
    (
        6,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 6
)


class getTableFilePaths_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTableFilePaths_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTableFilePaths_result)
getTableFilePaths_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getFileMetadata_args(object):
    """
    Attributes:
     - fileStatus
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        fileStatus=None,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.fileStatus = fileStatus
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fileStatus = []
                    (_etype119, _size116) = iprot.readListBegin()
                    for _i120 in range(_size116):
                        _elem121 = FileStatus()
                        _elem121.read(iprot)
                        self.fileStatus.append(_elem121)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getFileMetadata_args")
        if self.fileStatus is not None:
            oprot.writeFieldBegin("fileStatus", TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.fileStatus))
            for iter122 in self.fileStatus:
                iter122.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 3)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 4)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getFileMetadata_args)
getFileMetadata_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "fileStatus",
        (TType.STRUCT, [FileStatus, None], False),
        None,
    ),  # 1
    None,  # 2
    (
        3,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 4
)


class getFileMetadata_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getFileMetadata_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getFileMetadata_result)
getFileMetadata_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getAdditionalData_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - partitions
     - connectionMetadata
     - snopShotVersion
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        partitions=None,
        connectionMetadata=None,
        snopShotVersion=None,
        requestContext=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.partitions = partitions
        self.connectionMetadata = connectionMetadata
        self.snopShotVersion = snopShotVersion
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype126, _size123) = iprot.readListBegin()
                    for _i127 in range(_size123):
                        _elem128 = guardrail.e6_metadata_common.ttypes.E6PartitionInfo()
                        _elem128.read(iprot)
                        self.partitions.append(_elem128)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.snopShotVersion = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getAdditionalData_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin("partitions", TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter129 in self.partitions:
                iter129.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 5)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.snopShotVersion is not None:
            oprot.writeFieldBegin("snopShotVersion", TType.I64, 6)
            oprot.writeI64(self.snopShotVersion)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 7)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getAdditionalData_args)
getAdditionalData_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "partitions",
        (TType.STRUCT, [guardrail.e6_metadata_common.ttypes.E6PartitionInfo, None], False),
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 5
    (
        6,
        TType.I64,
        "snopShotVersion",
        None,
        None,
    ),  # 6
    (
        7,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 7
)


class getAdditionalData_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getAdditionalData_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getAdditionalData_result)
getAdditionalData_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class calculateStats_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - columnNames
     - partFilesToAnalyze
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        columnNames=None,
        partFilesToAnalyze=None,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.columnNames = columnNames
        self.partFilesToAnalyze = partFilesToAnalyze
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.columnNames = []
                    (_etype133, _size130) = iprot.readListBegin()
                    for _i134 in range(_size130):
                        _elem135 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.columnNames.append(_elem135)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.partFilesToAnalyze = {}
                    (_ktype137, _vtype138, _size136) = iprot.readMapBegin()
                    for _i140 in range(_size136):
                        _key141 = []
                        (_etype146, _size143) = iprot.readListBegin()
                        for _i147 in range(_size143):
                            _elem148 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _key141.append(_elem148)
                        iprot.readListEnd()
                        _val142 = []
                        (_etype152, _size149) = iprot.readListBegin()
                        for _i153 in range(_size149):
                            _elem154 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val142.append(_elem154)
                        iprot.readListEnd()
                        self.partFilesToAnalyze[_key141] = _val142
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("calculateStats_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.columnNames is not None:
            oprot.writeFieldBegin("columnNames", TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.columnNames))
            for iter155 in self.columnNames:
                oprot.writeString(iter155.encode("utf-8") if sys.version_info[0] == 2 else iter155)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partFilesToAnalyze is not None:
            oprot.writeFieldBegin("partFilesToAnalyze", TType.MAP, 5)
            oprot.writeMapBegin(TType.LIST, TType.LIST, len(self.partFilesToAnalyze))
            for kiter156, viter157 in self.partFilesToAnalyze.items():
                oprot.writeListBegin(TType.STRING, len(kiter156))
                for iter158 in kiter156:
                    oprot.writeString(
                        iter158.encode("utf-8") if sys.version_info[0] == 2 else iter158
                    )
                oprot.writeListEnd()
                oprot.writeListBegin(TType.STRING, len(viter157))
                for iter159 in viter157:
                    oprot.writeString(
                        iter159.encode("utf-8") if sys.version_info[0] == 2 else iter159
                    )
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 6)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 7)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(calculateStats_args)
calculateStats_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "columnNames",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 4
    (
        5,
        TType.MAP,
        "partFilesToAnalyze",
        (
            TType.LIST,
            (TType.STRING, "UTF8", False),
            TType.LIST,
            (TType.STRING, "UTF8", False),
            False,
        ),
        None,
    ),  # 5
    (
        6,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 6
    (
        7,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 7
)


class calculateStats_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CalculatedStats()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("calculateStats_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(calculateStats_result)
calculateStats_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [CalculatedStats, None],
        None,
    ),  # 0
)


class getTablePartitionsForDelta_args(object):
    """
    Attributes:
     - catalogName
     - dbName
     - tableName
     - deltaTablePartitionInfo
     - tableVersionInfo
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        catalogName=None,
        dbName=None,
        tableName=None,
        deltaTablePartitionInfo=None,
        tableVersionInfo=None,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.deltaTablePartitionInfo = deltaTablePartitionInfo
        self.tableVersionInfo = tableVersionInfo
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.deltaTablePartitionInfo = DeltaTablePartitionInfo()
                    self.deltaTablePartitionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.tableVersionInfo = guardrail.e6_metadata_common.ttypes.TableVersionInfo()
                    self.tableVersionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitionsForDelta_args")
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 1)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 2)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 3)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.deltaTablePartitionInfo is not None:
            oprot.writeFieldBegin("deltaTablePartitionInfo", TType.STRUCT, 4)
            self.deltaTablePartitionInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.tableVersionInfo is not None:
            oprot.writeFieldBegin("tableVersionInfo", TType.STRUCT, 5)
            self.tableVersionInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 6)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 7)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitionsForDelta_args)
getTablePartitionsForDelta_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "deltaTablePartitionInfo",
        [DeltaTablePartitionInfo, None],
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "tableVersionInfo",
        [guardrail.e6_metadata_common.ttypes.TableVersionInfo, None],
        None,
    ),  # 5
    (
        6,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 6
    (
        7,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 7
)


class getTablePartitionsForDelta_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getTablePartitionsForDelta_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getTablePartitionsForDelta_result)
getTablePartitionsForDelta_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class getMetastoreUsers_args(object):
    """
    Attributes:
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetastoreUsers_args")
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 1)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetastoreUsers_args)
getMetastoreUsers_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 2
)


class getMetastoreUsers_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype163, _size160) = iprot.readListBegin()
                    for _i164 in range(_size160):
                        _elem165 = MetastoreUser()
                        _elem165.read(iprot)
                        self.success.append(_elem165)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetastoreUsers_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter166 in self.success:
                iter166.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetastoreUsers_result)
getMetastoreUsers_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [MetastoreUser, None], False),
        None,
    ),  # 0
)


class getMetastoreGroups_args(object):
    """
    Attributes:
     - connectionMetadata
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        connectionMetadata=None,
        requestContext=None,
    ):
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetastoreGroups_args")
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 1)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetastoreGroups_args)
getMetastoreGroups_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 2
)


class getMetastoreGroups_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype170, _size167) = iprot.readListBegin()
                    for _i171 in range(_size167):
                        _elem172 = MetastoreGroup()
                        _elem172.read(iprot)
                        self.success.append(_elem172)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetastoreGroups_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter173 in self.success:
                iter173.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetastoreGroups_result)
getMetastoreGroups_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [MetastoreGroup, None], False),
        None,
    ),  # 0
)


class getMetastorePermissions_catalog_args(object):
    """
    Attributes:
     - connectionMetadata
     - requestContext
     - catalog

    """

    thrift_spec = None

    def __init__(
        self,
        connectionMetadata=None,
        requestContext=None,
        catalog=None,
    ):
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext
        self.catalog = catalog

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.catalog = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetastorePermissions_catalog_args")
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 1)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog is not None:
            oprot.writeFieldBegin("catalog", TType.STRING, 3)
            oprot.writeString(
                self.catalog.encode("utf-8") if sys.version_info[0] == 2 else self.catalog
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetastorePermissions_catalog_args)
getMetastorePermissions_catalog_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "catalog",
        "UTF8",
        None,
    ),  # 3
)


class getMetastorePermissions_catalog_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype177, _size174) = iprot.readListBegin()
                    for _i178 in range(_size174):
                        _elem179 = MetastorePermission()
                        _elem179.read(iprot)
                        self.success.append(_elem179)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetastorePermissions_catalog_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter180 in self.success:
                iter180.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetastorePermissions_catalog_result)
getMetastorePermissions_catalog_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [MetastorePermission, None], False),
        None,
    ),  # 0
)


class getMetastorePermissions_schema_args(object):
    """
    Attributes:
     - connectionMetadata
     - requestContext
     - catalog
     - schema

    """

    thrift_spec = None

    def __init__(
        self,
        connectionMetadata=None,
        requestContext=None,
        catalog=None,
        schema=None,
    ):
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext
        self.catalog = catalog
        self.schema = schema

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.catalog = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.schema = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetastorePermissions_schema_args")
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 1)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog is not None:
            oprot.writeFieldBegin("catalog", TType.STRING, 3)
            oprot.writeString(
                self.catalog.encode("utf-8") if sys.version_info[0] == 2 else self.catalog
            )
            oprot.writeFieldEnd()
        if self.schema is not None:
            oprot.writeFieldBegin("schema", TType.STRING, 4)
            oprot.writeString(
                self.schema.encode("utf-8") if sys.version_info[0] == 2 else self.schema
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetastorePermissions_schema_args)
getMetastorePermissions_schema_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "catalog",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "schema",
        "UTF8",
        None,
    ),  # 4
)


class getMetastorePermissions_schema_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype184, _size181) = iprot.readListBegin()
                    for _i185 in range(_size181):
                        _elem186 = MetastorePermission()
                        _elem186.read(iprot)
                        self.success.append(_elem186)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetastorePermissions_schema_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter187 in self.success:
                iter187.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetastorePermissions_schema_result)
getMetastorePermissions_schema_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [MetastorePermission, None], False),
        None,
    ),  # 0
)


class getMetastorePermissions_table_args(object):
    """
    Attributes:
     - connectionMetadata
     - requestContext
     - catalog
     - schema
     - table

    """

    thrift_spec = None

    def __init__(
        self,
        connectionMetadata=None,
        requestContext=None,
        catalog=None,
        schema=None,
        table=None,
    ):
        self.connectionMetadata = connectionMetadata
        self.requestContext = requestContext
        self.catalog = catalog
        self.schema = schema
        self.table = table

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.catalog = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.schema = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.table = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetastorePermissions_table_args")
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 1)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 2)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog is not None:
            oprot.writeFieldBegin("catalog", TType.STRING, 3)
            oprot.writeString(
                self.catalog.encode("utf-8") if sys.version_info[0] == 2 else self.catalog
            )
            oprot.writeFieldEnd()
        if self.schema is not None:
            oprot.writeFieldBegin("schema", TType.STRING, 4)
            oprot.writeString(
                self.schema.encode("utf-8") if sys.version_info[0] == 2 else self.schema
            )
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin("table", TType.STRING, 5)
            oprot.writeString(
                self.table.encode("utf-8") if sys.version_info[0] == 2 else self.table
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetastorePermissions_table_args)
getMetastorePermissions_table_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "catalog",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "schema",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "table",
        "UTF8",
        None,
    ),  # 5
)


class getMetastorePermissions_table_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = MetastorePermission()
                        _elem193.read(iprot)
                        self.success.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("getMetastorePermissions_table_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter194 in self.success:
                iter194.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(getMetastorePermissions_table_result)
getMetastorePermissions_table_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [MetastorePermission, None], False),
        None,
    ),  # 0
)


class createView_args(object):
    """
    Attributes:
     - connectionMetadata
     - catalogName
     - dbName
     - tableName
     - requestContext
     - bytes

    """

    thrift_spec = None

    def __init__(
        self,
        connectionMetadata=None,
        catalogName=None,
        dbName=None,
        tableName=None,
        requestContext=None,
        bytes=None,
    ):
        self.connectionMetadata = connectionMetadata
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.requestContext = requestContext
        self.bytes = bytes

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.bytes = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("createView_args")
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 1)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 2)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 3)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 4)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 5)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        if self.bytes is not None:
            oprot.writeFieldBegin("bytes", TType.STRING, 6)
            oprot.writeBinary(self.bytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(createView_args)
createView_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 5
    (
        6,
        TType.STRING,
        "bytes",
        "BINARY",
        None,
    ),  # 6
)


class createView_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("createView_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(createView_result)
createView_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class updateView_args(object):
    """
    Attributes:
     - connectionMetadata
     - catalogName
     - databaseName
     - tableName
     - bytes
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        connectionMetadata=None,
        catalogName=None,
        databaseName=None,
        tableName=None,
        bytes=None,
        requestContext=None,
    ):
        self.connectionMetadata = connectionMetadata
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.tableName = tableName
        self.bytes = bytes
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.databaseName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.bytes = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("updateView_args")
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 1)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 2)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.databaseName is not None:
            oprot.writeFieldBegin("databaseName", TType.STRING, 3)
            oprot.writeString(
                self.databaseName.encode("utf-8") if sys.version_info[0] == 2 else self.databaseName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 4)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.bytes is not None:
            oprot.writeFieldBegin("bytes", TType.STRING, 5)
            oprot.writeBinary(self.bytes)
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 6)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(updateView_args)
updateView_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "databaseName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "bytes",
        "BINARY",
        None,
    ),  # 5
    (
        6,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 6
)


class updateView_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("updateView_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(updateView_result)
updateView_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)


class dropView_args(object):
    """
    Attributes:
     - connectionMetadata
     - catalogName
     - dbName
     - tableName
     - requestContext

    """

    thrift_spec = None

    def __init__(
        self,
        connectionMetadata=None,
        catalogName=None,
        dbName=None,
        tableName=None,
        requestContext=None,
    ):
        self.connectionMetadata = connectionMetadata
        self.catalogName = catalogName
        self.dbName = dbName
        self.tableName = tableName
        self.requestContext = requestContext

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.connectionMetadata = ConnectionMetadata()
                    self.connectionMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalogName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tableName = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.requestContext = RequestContext()
                    self.requestContext.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("dropView_args")
        if self.connectionMetadata is not None:
            oprot.writeFieldBegin("connectionMetadata", TType.STRUCT, 1)
            self.connectionMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogName is not None:
            oprot.writeFieldBegin("catalogName", TType.STRING, 2)
            oprot.writeString(
                self.catalogName.encode("utf-8") if sys.version_info[0] == 2 else self.catalogName
            )
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin("dbName", TType.STRING, 3)
            oprot.writeString(
                self.dbName.encode("utf-8") if sys.version_info[0] == 2 else self.dbName
            )
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin("tableName", TType.STRING, 4)
            oprot.writeString(
                self.tableName.encode("utf-8") if sys.version_info[0] == 2 else self.tableName
            )
            oprot.writeFieldEnd()
        if self.requestContext is not None:
            oprot.writeFieldBegin("requestContext", TType.STRUCT, 5)
            self.requestContext.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(dropView_args)
dropView_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "connectionMetadata",
        [ConnectionMetadata, None],
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "catalogName",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "dbName",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "tableName",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "requestContext",
        [RequestContext, None],
        None,
    ),  # 5
)


class dropView_result(object):
    """
    Attributes:
     - error1

    """

    thrift_spec = None

    def __init__(
        self,
        error1=None,
    ):
        self.error1 = error1

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = SchemaServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("dropView_result")
        if self.error1 is not None:
            oprot.writeFieldBegin("error1", TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(dropView_result)
dropView_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "error1",
        [SchemaServiceException, None],
        None,
    ),  # 1
)
fix_spec(all_structs)
del all_structs
